<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="RPA.JSON" type="LIBRARY" format="REST" scope="GLOBAL" generated="2023-03-15T12:04:06Z" specversion="4" source="./RPA/JSON.py" lineno="40">
<version/>
<doc>`JSON` is a library for manipulating `JSON`_ files and strings.

JSON is a common data interchange format inspired by a subset of
the Javascript programming language, but these days is a de facto
standard in modern web APIs and is language agnostic.

.. _JSON: http://json.org/

Serialization
=============

The term `serialization` refers to the process of converting
Robot Framework or Python types to JSON or the other way around.

Basic types can be easily converted between the domains,
and the mapping is as follows:

============= =======
JSON          Python
============= =======
object        dict
array         list
string        str
number (int)  int
number (real) float
true          True
false         False
null          None
============= =======

About JSONPath
==============

Reading and writing values from/to JSON serializable objects is done
using `JSONPath`_. It's a syntax designed to quickly and easily refer to
specific elements in a JSON structure. The specific flavor used in this
library is based on `jsonpath-ng`_.

Compared to Python's normal dictionary access, JSONPath expressions can
target multiple elements through features such as conditionals and wildcards,
which can simplify many JSON-related operations. It's analogous to XPath
for XML structures.

.. _JSONPath: http://goessner.net/articles/JsonPath/
.. _jsonpath-ng: https://pypi.org/project/jsonpath-ng/#description

Syntax example
--------------

For this example consider the following structure:

.. code-block:: json

   {
     "clients": [
       {
         "name": "Johnny Example",
         "email": "john@example.com",
         "orders": [
             {"address": "Streetroad 123", "price": 103.20},
             {"address": "Streetroad 123", "price": 98.99}
         ]
       },
       {
         "name": "Jane Example",
         "email": "jane@example.com",
         "orders": [
             {"address": "Waypath 321", "price": 22.00},
             {"address": "Streetroad 123", "price": 2330.01}
         ]
       }
     ]
   }

In the simplest case JSONPath can replace nested access:

.. code-block:: robotframework

    *** Tasks ***
    Nested access
        # First order of first client, with direct dictionary access
        ${value}=    Set variable    ${json}["clients"][0]["orders"][0]

        # JSONPath access
        ${value}=    Get value from JSON    ${json}    $.clients[0].orders[0]

But the power comes from complicated expressions:

.. code-block:: robotframework

    *** Tasks ***
    Complicated expressions
        # Find delivery addresses for all orders
        ${prices}=        Get values from JSON    $..address

        # Find orders that cost over 100
        ${expensives}=    Get values from JSON    $..orders[?(@.price&gt;100)]


Supported Expressions
---------------------

The supported syntax elements are:

=======================    ===========
Element                    Description
=======================    ===========
``$``                      Root object/element
``@``                      Current object/element inside expressions
``.`` or ``[]``            Child operator
``..``                     Recursive descendant operator
````parent````             Parent operator, see `functions`_
``*``                      Wilcard, any element
``,``                      Select multiple fields
``[n]``                    Array index
``[a:b:c]``                Array slice (start, end, step)
``[a,b]``                  Union of indices or names
``[?()]``                  Apply a filter expression
``()``                     Script expression
``[\\field]``              Sort descending by ``field``, cannot be combined with
                           filters.
``[/field]``               Sort ascending by ``field``, cannot be combined with
                           filters.
````str()````              Convert value to string, see `functions`_
````sub()````              Regex substitution function, see `functions`_
````len````                Calculate value's length, see `functions`_
````split()````            String split function, see `functions`_
``+`` ``-`` ``*`` ``/``    Arithmetic functions, see `functions`_
=======================    ===========

Functions
^^^^^^^^^

This library allows JSON path expressions to include certain functions
which can provide additional benefit to users. These functions are
generally encapsulated in backticks (`````). Some functions require
you to pass arguments similar to a Python function.

For example, let's say a JSON has nodes on the JSON path
``$.books[*].genres`` which are represented as strings of genres with
commas separating each genre. So for one book, this node might have a
value like ``horror,young-adult``. You can return a list of first genre
for each book by using the ``split`` function like so:

.. code-block:: robotframework

    *** Task ***
    Get genres
        ${genres}=  Get values from JSON    $.books[*].genres.```split(,, 0, -1)```

Each functions parameters are defined here:

===================================  =====
Function                             Usage
===================================  =====
``str()``                            No parameters, but parenthesis are required
``sub(/regex/, repl)``               The regex pattern must be provided in *regex*
                                     and the replacement value provided in *repl*
``len``                              No parameters and no parenthesis
``split(char, segment, max_split)``  Separator character provided as *char*, which
                                     index from the resulting array to be returns
                                     provided as *segment*, and maximum number of
                                     splits to perform provided as *max_split*,
                                     ``-1`` for all splits.
``parent``                           No parameters, no parenthesis
===================================  =====

**Arithmetic Functions**

JSON Path can be written and combined to concatenate string values
or perform arithmetic functions on numerical values. Each JSONPath
expression used must return the same type, and when performing
such functions between returned lists, each list must be the same
length. An example is included in documentation for the keyword
\`Get values from JSON\`.

Additional Information
^^^^^^^^^^^^^^^^^^^^^^

There are a multitude of different script expressions
in addition to the elements listed above, which can
be seen in the `aforementioned article`__.

For further library usage examples, see the individual keywords.

__ JSONPath_</doc>
<tags>
</tags>
<inits>
</inits>
<keywords>
<kw name="Add to JSON" lineno="372">
<arguments repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None, expr: str, value: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>doc</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>value</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
</arguments>
<doc>Add items into a JSON serializable object and return the result.

If the target is a list, the values are appended to the end.
If the target is a dict, the keys are either added or updated.

:param doc: JSON serializable object
:param expr: JSONPath expression
:param value: values to either append or update
:return: JSON serializable object of the updated JSON

Robot Framework Example:

.. code:: robotframework

    *** Task ***
    Change the name value for all people
        &amp;{before}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
        &amp;{person}=    Create dictionary      Name=John
        &amp;{after}=     Add to JSON    ${before}   $.People    ${person}

Python Example:

.. code:: python

    from RPA.JSON import JSON

    # Change the name value for all people
    js = JSON()
    before = js.convert_string_to_json('{"People": [{"Name": "Mark"}, {"Name": "Jane"}]}')
    person = {"Name": "John"}
    after = js.add_to_json(before, "$.People", person)

    print(after)</doc>
<shortdoc>Add items into a JSON serializable object and return the result.</shortdoc>
</kw>
<kw name="Convert JSON to String" lineno="310">
<arguments repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>doc</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
</arguments>
<doc>Convert a JSON serializable object to a string and return it.

:param doc: JSON serializable object
:return: string of the JSON serializable object

Robot Framework Example:

.. code:: robotframework

    *** Task ***
    Convert to string
        ${obj}=    Create dictionary    Key=Value
        ${json}=   Convert JSON to string    ${obj}
        Should be equal    ${json}     {"Key": "Value"}

Python Example:

.. code:: python

    from RPA.JSON import JSON
    from robot.libraries.BuiltIn import BuiltIn

    obj = {"Key": "Value"}
    json = JSON().convert_json_to_string(obj)
    BuiltIn().should_be_equal(json, '{"Key": "Value"}')</doc>
<shortdoc>Convert a JSON serializable object to a string and return it.</shortdoc>
</kw>
<kw name="Convert String to JSON" lineno="341">
<arguments repr="doc: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: str">
<name>doc</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Convert a string to a JSON serializable object and return it.

:param doc: JSON string
:return: JSON serializable object of the string

Robot Framework Example:

.. code:: robotframework

    *** Task ***
    Convert to json
        ${json}=    Set variable    {"Key": "Value"}
        &amp;{obj}=     Convert string to JSON    ${json}
        Should be equal    ${obj.Key}    Value

Python Example:

.. code:: python

    from RPA.JSON import JSON
    from robot.libraries.BuiltIn import BuiltIn

    json = '{"Key": "Value"}'
    obj = JSON().convert_string_to_json(json)
    BuiltIn().should_be_equal(obj["Key"], "Value")</doc>
<shortdoc>Convert a string to a JSON serializable object and return it.</shortdoc>
</kw>
<kw name="Delete from JSON" lineno="709">
<arguments repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None, expr: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>doc</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Delete values from a JSON serializable object and return the result.
Will delete all values that match the expression.

:param doc: JSON serializable object or string
:param expr: JSONPath expression
:return: JSON serializable object with values removed

Example:

.. code:: robotframework

    *** Task ***
    Delete all people
        &amp;{before}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
        &amp;{after}=     Delete from JSON    ${before}   $.People[*]

.. code:: python

    from RPA.JSON import JSON

    # Delete all people
    before = {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
    after = JSON().delete_from_json(before, "$.People[*]")
    print(after)</doc>
<shortdoc>Delete values from a JSON serializable object and return the result. Will delete all values that match the expression.</shortdoc>
</kw>
<kw name="Get value from JSON" lineno="417">
<arguments repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None, expr: str, default: Any | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>doc</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="default: Any | None = None">
<name>default</name>
<type>Any</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Get a single value from a JSON serializable object that matches the given expression.

Raises a ValueError if there is more than one match.
Returns the given default argument (or None) if there
were no matches.

:param doc: JSON serializable object or string
:param expr: jsonpath expression
:param default: default value to return in the absence of a match
:return: string containing the match OR `default` if there are no matches
:raises ValueError: if more than one match is discovered

Short Robot Framework Example:

.. code:: robotframework

    *** Task ***
    Get the name value for the first person
        &amp;{people}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
        ${first}=     Get value from JSON      ${people}   $.People[0].Name

Short Python Example:

.. code:: python

    from RPA.JSON import JSON

    # Get the name value for the second person.
    people = {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
    second = JSON().get_value_from_json(people, "$.People[1].Name")
    print(second)

Extended Robot Framework Example:

.. code:: robotframework

    *** Settings ***
    Library         RPA.JSON
    Suite Setup     Ingest JSON

    *** Variables ***
    ${JSON_STRING}      {
    ...                   "clients": [
    ...                     {
    ...                       "name": "Johnny Example",
    ...                       "email": "john@example.com",
    ...                       "orders": [
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 103.20, "id":"guid-001"},
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 98.99, "id":"guid-002"}
    ...                       ]
    ...                     },
    ...                     {
    ...                       "name": "Jane Example",
    ...                       "email": "jane@example.com",
    ...                       "orders": [
    ...                         {"address": "Waypath 321", "state": "WA", "price": 22.00, "id":"guid-003"},
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 2330.01, "id":"guid-004"},
    ...                         {"address": "Waypath 321", "state": "WA", "price": 152.12, "id":"guid-005"}
    ...                       ]
    ...                     }
    ...                   ]
    ...                 }
    ${ID}               guid-003

    *** Tasks ***
    Get email for specific order id
        ${email}=    Get value from json    ${JSON_DOC}    $.clients[?(@..id=="${ID}")].email
        Log    \nOUTPUT IS\n ${email}    console=${True}
        Should be equal as strings    ${email}    jane@example.com

    *** Keywords ***
    Ingest JSON
        ${doc}=    Convert string to json    ${JSON_STRING}
        Set suite variable    ${JSON_DOC}    ${doc}</doc>
<shortdoc>Get a single value from a JSON serializable object that matches the given expression.</shortdoc>
</kw>
<kw name="Get values from JSON" lineno="508">
<arguments repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None, expr: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>doc</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Get all values from a JSON serializable object that match the given expression.

:param doc: JSON serializable object or string
:param expr: JSONPath expression
:return: list of values that match

Short Robot Framework Example:

.. code:: robotframework

    *** Task ***
    Get all the names for all people
        &amp;{people}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
        @{names}=     Get values from JSON     ${people}   $.People[*].Name

Short Python Example:

.. code:: python

    from RPA.JSON import JSON

    # Get all the names for all people
    people = {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
    names = JSON().get_values_from_json(people, "$.People[*].Name")
    print(second)

Extended Robot Framework Example:

.. code:: robotframework

    *** Settings ***
    Library         RPA.JSON
    Suite Setup     Ingest JSON

    *** Variables ***
    ${JSON_STRING}      {
    ...                   "clients": [
    ...                     {
    ...                       "name": "Johnny Example",
    ...                       "email": "john@example.com",
    ...                       "orders": [
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 103.20, "id":"guid-001"},
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 98.99, "id":"guid-002"}
    ...                       ]
    ...                     },
    ...                     {
    ...                       "name": "Jane Example",
    ...                       "email": "jane@example.com",
    ...                       "orders": [
    ...                         {"address": "Waypath 321", "state": "WA", "price": 22.00, "id":"guid-003"},
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 2330.01, "id":"guid-004"},
    ...                         {"address": "Waypath 321", "state": "WA", "price": 152.12, "id":"guid-005"}
    ...                       ]
    ...                     }
    ...                   ]
    ...                 }
    ${ID}               guid-003

    *** Tasks ***
    Get All Prices and Order Ids
        # Arithmetic operations only work when lists are of equal lengths and types.
        ${prices}=    Get values from json
        ...    ${JSON_DOC}
        ...    $.clients[*].orders[*].id + " has price " + $.clients[*].orders[*].price.```str()```
        Log    \nOUTPUT IS\n ${prices}    console=${True}
        Should be equal as strings    ${prices}
        ...    ['guid-001 has price 103.2', 'guid-002 has price 98.99', 'guid-003 has price 22.0', 'guid-004 has price 2330.01', 'guid-005 has price 152.12']

    Find Only Valid Emails With Regex
        # The regex used in this example is simplistic and
        # will not work with all email addresses
        ${emails}=    Get values from json
        ...    ${JSON_DOC}
        ...    $.clients[?(@.email =~ "[a-zA-Z]+@[a-zA-Z]+\.[a-zA-Z]+")].email
        Log    \nOUTPUT IS\n ${emails}    console=${True}
        Should be equal as strings    ${emails}    ['john@example.com', 'jane@example.com']

    Find Orders From Texas Over 100
        # The regex used in this example is simplistic and
        # will not work with all email addresses
        ${orders}=    Get values from json
        ...    ${JSON_DOC}
        ...    $.clients[*].orders[?(@.price &gt; 100 &amp; @.state == "TX")]
        Log    \nOUTPUT IS\n ${orders}    console=${True}
        Should be equal as strings    ${orders}
        ...    [{'address': 'Streetroad 123', 'state': 'TX', 'price': 103.2, 'id': 'guid-001'}, {'address': 'Streetroad 123', 'state': 'TX', 'price': 2330.01, 'id': 'guid-004'}]


    *** Keywords ***
    Ingest JSON
        ${doc}=    Convert string to json    ${JSON_STRING}
        Set suite variable    ${JSON_DOC}    ${doc}</doc>
<shortdoc>Get all values from a JSON serializable object that match the given expression.</shortdoc>
</kw>
<kw name="Load JSON from file" lineno="238">
<arguments repr="filename: str, encoding=utf-8">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="filename: str">
<name>filename</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="encoding=utf-8">
<name>encoding</name>
<default>utf-8</default>
</arg>
</arguments>
<doc>Load JSON data from a file, and return it as JSON serializable object.
Depending on the input file the object can be either a dictionary,
a list, or a scalar value.

:param filename: path to input file
:param encoding: file character encoding
:return: JSON serializable object of the JSON file

Example:

.. code:: robotframework

    *** Task ***
    Load json
        &amp;{auth}=    Load JSON from file    auth.json
        Log   Current auth token: ${auth.token}</doc>
<shortdoc>Load JSON data from a file, and return it as JSON serializable object. Depending on the input file the object can be either a dictionary, a list, or a scalar value.</shortdoc>
</kw>
<kw name="Save JSON to file" lineno="262">
<arguments repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None, filename: str, indent: int | None = None, encoding: str = utf-8">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>doc</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="filename: str">
<name>filename</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="indent: int | None = None">
<name>indent</name>
<type typedoc="integer">int</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="encoding: str = utf-8">
<name>encoding</name>
<type typedoc="string">str</type>
<default>utf-8</default>
</arg>
</arguments>
<doc>Save a JSON serializable object or a string containing
a JSON value into a file.

:param doc: JSON serializable object or string
:param filename: path to output file
:param indent: if given this value is used for json file indent
:param encoding: file character encoding

Robot Framework Example:

.. code:: robotframework

    *** Tasks ***
    Save dictionary to file
        ${john}=    Create dictionary    name=John    mail=john@example.com
        Save JSON to file    ${john}    john.json

    Save string to file
        ${mark}=    Set variable    {"name": "Mark", "mail": "mark@example.com"}
        Save JSON to file    ${mark}    mark.json

Python Example:

.. code:: python

    from RPA.JSON import JSON

    # Save dictionary to file.
    john = {"name": "John", "mail": "john@example.com"}
    JSON().save_json_to_file(john, "john.json")</doc>
<shortdoc>Save a JSON serializable object or a string containing a JSON value into a file.</shortdoc>
</kw>
<kw name="Update value to JSON" lineno="607">
<arguments repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None, expr: str, value: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="doc: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>doc</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expr: str">
<name>expr</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: Dict[Hashable, str | int | float | bool | list | dict | None] | List[str | int | float | bool | list | dict | None] | str | int | float | bool | list | dict | None">
<name>value</name>
<type typedoc="dictionary">Dict[Hashable, str | int | float | bool | list | dict | None]</type>
<type typedoc="list">List[str | int | float | bool | list | dict | None]</type>
<type typedoc="string">str</type>
<type typedoc="integer">int</type>
<type typedoc="float">float</type>
<type typedoc="boolean">bool</type>
<type typedoc="list">list</type>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
</arg>
</arguments>
<doc>Update existing values in a JSON serializable object and return the result.
Will change all values that match the expression.

:param doc: JSON or string
:param expr: JSONPath expression
:param value: New value for the matching item(s)
:return: JSON serializable object with updated results

Short Robot Framework Example:

.. code:: robotframework

    *** Tasks ***
    Change the name key for all people
        &amp;{before}=    Convert string to JSON   {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
        &amp;{after}=     Update value to JSON     ${before}   $.People[*].Name    JohnMalkovich

.. code:: python

    from RPA.JSON import JSON

    # Change the name key for all people
    before = {"People": [{"Name": "Mark"}, {"Name": "Jane"}]}
    after = JSON().update_value_to_json(before, "$.People[*].Name","JohnMalkovich")
    print(after)

Extended Robot Framework Example:

.. code:: robotframework

    *** Settings ***
    Library         RPA.JSON
    Library    Collections
    Suite Setup     Ingest JSON

    *** Variables ***
    ${JSON_STRING}      {
    ...                   "clients": [
    ...                     {
    ...                       "name": "Johnny Example",
    ...                       "email": "john@example.com",
    ...                       "id": "user-001",
    ...                       "orders": [
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 103.20, "id":"guid-001"},
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 98.99, "id":"guid-002"}
    ...                       ]
    ...                     },
    ...                     {
    ...                       "name": "Jane Example",
    ...                       "email": "jane@example.com",
    ...                       "id": "user-002",
    ...                       "orders": [
    ...                         {"address": "Waypath 321", "state": "WA", "price": 22.00, "id":"guid-003"},
    ...                         {"address": "Streetroad 123", "state": "TX", "price": 2330.01, "id":"guid-004"},
    ...                         {"address": "Waypath 321", "state": "WA", "price": 152.12, "id":"guid-005"}
    ...                       ]
    ...                     }
    ...                   ]
    ...                 }
    ${ID}               guid-003

    *** Tasks ***
    Update user email
        ${updated_doc}=    Update value to json
        ...    ${JSON_DOC}
        ...    $.clients[?(@.id=="user-001")].email
        ...    johnny@example.com
        Log    \nNEW JSON IS\n ${updated_doc}    console=${True}
        ${new_email}=    Get value from json    ${updated_doc}    $.clients[?(@.id=="user-001")].email
        Should be equal as strings    ${new_email}    johnny@example.com

    Add additional charge to all prices in WA
        # This example also shows how the update keyword changes the original JSON doc in memory.
        ${id_price}=    Get values from json
        ...    ${JSON_DOC}
        ...    $.clients[*].orders[?(@.state=="WA")].id,price
        FOR    ${order_id}    ${price}    IN    @{id_price}
            Update value to json    ${JSON_DOC}    $.clients[*].orders[?(@.id=="${order_id}")].price    ${{${price} * 1.06}}
        END
        Log    \nNEW JSON IS\n ${JSON_DOC}    console=${True}
        ${one_price}=    Get value from json    ${JSON_DOC}    $..orders[?(@.id==${ID})].price
        Should be equal as numbers    ${one_price}    23.32

    *** Keywords ***
    Ingest JSON
        ${doc}=    Convert string to json    ${JSON_STRING}
        Set suite variable    ${JSON_DOC}    ${doc}</doc>
<shortdoc>Update existing values in a JSON serializable object and return the result. Will change all values that match the expression.</shortdoc>
</kw>
</keywords>
<datatypes>
</datatypes>
<typedocs>
<type name="boolean" type="Standard">
<doc>Strings ``TRUE``, ``YES``, ``ON`` and ``1`` are converted to Boolean ``True``,
the empty string as well as strings ``FALSE``, ``NO``, ``OFF`` and ``0``
are converted to Boolean ``False``, and the string ``NONE`` is converted
to the Python ``None`` object. Other strings and other accepted values are
passed as-is, allowing keywords to handle them specially if
needed. All string comparisons are case-insensitive.

Examples: ``TRUE`` (converted to ``True``), ``off`` (converted to ``False``),
``example`` (used as-is)
</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
<type>None</type>
</accepts>
<usages>
<usage>Add to JSON</usage>
<usage>Convert JSON to String</usage>
<usage>Delete from JSON</usage>
<usage>Get value from JSON</usage>
<usage>Get values from JSON</usage>
<usage>Save JSON to file</usage>
<usage>Update value to JSON</usage>
</usages>
</type>
<type name="dictionary" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#dict|dictionary]
literals. They are converted to actual dictionaries using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
dictionaries and other containers.

Examples: ``{'a': 1, 'b': 2}``, ``{'key': 1, 'nested': {'key': 2}}``
</doc>
<accepts>
<type>string</type>
<type>Mapping</type>
</accepts>
<usages>
<usage>Add to JSON</usage>
<usage>Convert JSON to String</usage>
<usage>Delete from JSON</usage>
<usage>Get value from JSON</usage>
<usage>Get values from JSON</usage>
<usage>Save JSON to file</usage>
<usage>Update value to JSON</usage>
</usages>
</type>
<type name="float" type="Standard">
<doc>Conversion is done using Python's
[https://docs.python.org/library/functions.html#float|float] built-in function.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``3.14``, ``2.9979e8``, ``10 000.000 01``
</doc>
<accepts>
<type>string</type>
<type>Real</type>
</accepts>
<usages>
<usage>Add to JSON</usage>
<usage>Convert JSON to String</usage>
<usage>Delete from JSON</usage>
<usage>Get value from JSON</usage>
<usage>Get values from JSON</usage>
<usage>Save JSON to file</usage>
<usage>Update value to JSON</usage>
</usages>
</type>
<type name="integer" type="Standard">
<doc>Conversion is done using Python's [https://docs.python.org/library/functions.html#int|int]
built-in function. Floating point
numbers are accepted only if they can be represented as integers exactly.
For example, ``1.0`` is accepted and ``1.1`` is not.

Starting from RF 4.1, it is possible to use hexadecimal, octal and binary
numbers by prefixing values with ``0x``, ``0o`` and ``0b``, respectively.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``42``, ``-1``, ``0b1010``, ``10 000 000``, ``0xBAD_C0FFEE``
</doc>
<accepts>
<type>string</type>
<type>float</type>
</accepts>
<usages>
<usage>Add to JSON</usage>
<usage>Convert JSON to String</usage>
<usage>Delete from JSON</usage>
<usage>Get value from JSON</usage>
<usage>Get values from JSON</usage>
<usage>Save JSON to file</usage>
<usage>Update value to JSON</usage>
</usages>
</type>
<type name="list" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#list|list]
literals. They are converted to actual lists using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
lists and other containers.

Examples: ``['one', 'two']``, ``[('one', 1), ('two', 2)]``
</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>Add to JSON</usage>
<usage>Convert JSON to String</usage>
<usage>Delete from JSON</usage>
<usage>Get value from JSON</usage>
<usage>Get values from JSON</usage>
<usage>Save JSON to file</usage>
<usage>Update value to JSON</usage>
</usages>
</type>
<type name="None" type="Standard">
<doc>String ``NONE`` (case-insensitive) is converted to Python ``None`` object.
Other values cause an error.
</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>Add to JSON</usage>
<usage>Convert JSON to String</usage>
<usage>Delete from JSON</usage>
<usage>Get value from JSON</usage>
<usage>Get values from JSON</usage>
<usage>Save JSON to file</usage>
<usage>Update value to JSON</usage>
</usages>
</type>
<type name="string" type="Standard">
<doc>All arguments are converted to Unicode strings.</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>Add to JSON</usage>
<usage>Convert JSON to String</usage>
<usage>Convert String to JSON</usage>
<usage>Delete from JSON</usage>
<usage>Get value from JSON</usage>
<usage>Get values from JSON</usage>
<usage>Load JSON from file</usage>
<usage>Save JSON to file</usage>
<usage>Update value to JSON</usage>
</usages>
</type>
</typedocs>
</keywordspec>
