<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="RPA.Browser" type="LIBRARY" format="ROBOT" scope="GLOBAL" generated="2023-03-15T12:04:04Z" specversion="4" source="./RPA/Browser/__init__.py" lineno="5">
<version>6.0.0</version>
<doc>SeleniumLibrary is a web testing library for Robot Framework.

This document explains how to use keywords provided by SeleniumLibrary.
For information about installation, support, and more, please visit the
[https://github.com/robotframework/SeleniumLibrary|project pages].
For more information about Robot Framework, see https://robotframework.org.

SeleniumLibrary uses the Selenium WebDriver modules internally to
control a web browser. See https://www.selenium.dev/ for more information
about Selenium in general and SeleniumLibrary README.rst
[https://github.com/robotframework/SeleniumLibrary#browser-drivers|Browser drivers chapter]
for more details about WebDriver binary installation.

= Locating elements =

All keywords in SeleniumLibrary that need to interact with an element
on a web page take an argument typically named ``locator`` that specifies
how to find the element. Most often the locator is given as a string
using the locator syntax described below, but `using WebElements` is
possible too.

== Locator syntax ==

SeleniumLibrary supports finding elements based on different strategies
such as the element id, XPath expressions, or CSS selectors. The strategy
can either be explicitly specified with a prefix or the strategy can be
implicit.

=== Default locator strategy ===

By default, locators are considered to use the keyword specific default
locator strategy. All keywords support finding elements based on ``id``
and ``name`` attributes, but some keywords support additional attributes
or other values that make sense in their context. For example, `Click
Link` supports the ``href`` attribute and the link text and addition
to the normal ``id`` and ``name``.

Examples:

| `Click Element` | example | # Match based on ``id`` or ``name``.            |
| `Click Link`    | example | # Match also based on link text and ``href``.   |
| `Click Button`  | example | # Match based on ``id``, ``name`` or ``value``. |

If a locator accidentally starts with a prefix recognized as `explicit
locator strategy` or `implicit XPath strategy`, it is possible to use
the explicit ``default`` prefix to enable the default strategy.

Examples:

| `Click Element` | name:foo         | # Find element with name ``foo``.               |
| `Click Element` | default:name:foo | # Use default strategy with value ``name:foo``. |
| `Click Element` | //foo            | # Find element using XPath ``//foo``.           |
| `Click Element` | default: //foo   | # Use default strategy with value ``//foo``.    |

=== Explicit locator strategy ===

The explicit locator strategy is specified with a prefix using either
syntax ``strategy:value`` or ``strategy=value``. The former syntax
is preferred because the latter is identical to Robot Framework's
[https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#named-argument-syntax|
named argument syntax] and that can cause problems. Spaces around
the separator are ignored, so ``id:foo``, ``id: foo`` and ``id : foo``
are all equivalent.

Locator strategies that are supported by default are listed in the table
below. In addition to them, it is possible to register `custom locators`.

| = Strategy = |          = Match based on =         |         = Example =            |
| id           | Element ``id``.                     | ``id:example``                 |
| name         | ``name`` attribute.                 | ``name:example``               |
| identifier   | Either ``id`` or ``name``.          | ``identifier:example``         |
| class        | Element ``class``.                  | ``class:example``              |
| tag          | Tag name.                           | ``tag:div``                    |
| xpath        | XPath expression.                   | ``xpath://div[@id="example"]`` |
| css          | CSS selector.                       | ``css:div#example``            |
| dom          | DOM expression.                     | ``dom:document.images[5]``     |
| link         | Exact text a link has.              | ``link:The example``           |
| partial link | Partial link text.                  | ``partial link:he ex``         |
| sizzle       | Sizzle selector deprecated.         | ``sizzle:div.example``         |
| data         | Element ``data-*`` attribute        | ``data:id:my_id``              |
| jquery       | jQuery expression.                  | ``jquery:div.example``         |
| default      | Keyword specific default behavior.  | ``default:example``            |

See the `Default locator strategy` section below for more information
about how the default strategy works. Using the explicit ``default``
prefix is only necessary if the locator value itself accidentally
matches some of the explicit strategies.

Different locator strategies have different pros and cons. Using ids,
either explicitly like ``id:foo`` or by using the `default locator
strategy` simply like ``foo``, is recommended when possible, because
the syntax is simple and locating elements by id is fast for browsers.
If an element does not have an id or the id is not stable, other
solutions need to be used. If an element has a unique tag name or class,
using ``tag``, ``class`` or ``css`` strategy like ``tag:h1``,
``class:example`` or ``css:h1.example`` is often an easy solution. In
more complex cases using XPath expressions is typically the best
approach. They are very powerful but a downside is that they can also
get complex.

Examples:

| `Click Element` | id:foo                      | # Element with id 'foo'. |
| `Click Element` | css:div#foo h1              | # h1 element under div with id 'foo'. |
| `Click Element` | xpath: //div[@id="foo"]//h1 | # Same as the above using XPath, not CSS. |
| `Click Element` | xpath: //*[contains(text(), "example")] | # Element containing text 'example'. |

*NOTE:*

- The ``strategy:value`` syntax is only supported by SeleniumLibrary 3.0
  and newer.
- Using the ``sizzle`` strategy or its alias ``jquery`` requires that
  the system under test contains the jQuery library.
- Prior to SeleniumLibrary 3.0, table related keywords only supported
  ``xpath``, ``css`` and ``sizzle/jquery`` strategies.
- ``data`` strategy is conveniance locator that will construct xpath from the parameters.
  If you have element like `&lt;div data-automation="automation-id-2"&gt;`, you locate the element via
  ``data:automation:automation-id-2``. This feature was added in SeleniumLibrary 5.2.0

=== Implicit XPath strategy ===

If the locator starts with ``//``  or multiple opening parenthesis in front
of the ``//``, the locator is considered to be an XPath expression. In other
words, using ``//div`` is equivalent to using explicit ``xpath://div`` and
``((//div))`` is equivalent to using explicit ``xpath:((//div))``

Examples:

| `Click Element` | //div[@id="foo"]//h1 |
| `Click Element` | (//div)[2]           |

The support for the ``(//`` prefix is new in SeleniumLibrary 3.0.
Supporting multiple opening parenthesis is new in SeleniumLibrary 5.0.

=== Chaining locators ===

It is possible chain multiple locators together as single locator. Each chained locator must start with locator
strategy. Chained locators must be separated with single space, two greater than characters and followed with
space. It is also possible mix different locator strategies, example css or xpath. Also a list can also be
used to specify multiple locators. This is useful, is some part of locator would match as the locator separator
but it should not. Or if there is need to existing WebElement as locator.

Although all locators support chaining, some locator strategies do not abey the chaining. This is because
some locator strategies use JavaScript to find elements and JavaScript is executed for the whole browser context
and not for the element found be the previous locator. Chaining is supported by locator strategies which
are based on Selenium API, like `xpath` or `css`, but example chaining is not supported by `sizzle` or `jquery

Examples:
| `Click Element` | css:.bar &gt;&gt; xpath://a | # To find a link which is present after an element with class "bar" |

List examples:
| ${locator_list} =             | `Create List`   | css:div#div_id            | xpath://*[text(), " &gt;&gt; "] |
| `Page Should Contain Element` | ${locator_list} |                           |                           |
| ${element} =                  | Get WebElement  | xpath://*[text(), " &gt;&gt; "] |                           |
| ${locator_list} =             | `Create List`   | css:div#div_id            | ${element}                |
| `Page Should Contain Element` | ${locator_list} |                           |                           |

Chaining locators in new in SeleniumLibrary 5.0

== Using WebElements ==

In addition to specifying a locator as a string, it is possible to use
Selenium's WebElement objects. This requires first getting a WebElement,
for example, by using the `Get WebElement` keyword.

| ${elem} =       | `Get WebElement` | id:example |
| `Click Element` | ${elem}          |            |

== Custom locators ==

If more complex lookups are required than what is provided through the
default locators, custom lookup strategies can be created. Using custom
locators is a two part process. First, create a keyword that returns
a WebElement that should be acted on:

| Custom Locator Strategy | [Arguments] | ${browser} | ${locator} | ${tag} | ${constraints} |
|   | ${element}= | Execute Javascript | return window.document.getElementById('${locator}'); |
|   | [Return] | ${element} |

This keyword is a reimplementation of the basic functionality of the
``id`` locator where ``${browser}`` is a reference to a WebDriver
instance and ``${locator}`` is the name of the locator strategy. To use
this locator, it must first be registered by using the
`Add Location Strategy` keyword:

| `Add Location Strategy` | custom | Custom Locator Strategy |

The first argument of `Add Location Strategy` specifies the name of
the strategy and it must be unique. After registering the strategy,
the usage is the same as with other locators:

| `Click Element` | custom:example |

See the `Add Location Strategy` keyword for more details.

= Browser and Window =

There is different conceptual meaning when SeleniumLibrary talks
about windows or browsers. This chapter explains those differences.

== Browser ==

When `Open Browser` or `Create WebDriver` keyword is called, it
will create a new Selenium WebDriver instance by using the
[https://www.seleniumhq.org/docs/03_webdriver.jsp|Selenium WebDriver]
API. In SeleniumLibrary terms, a new browser is created. It is
possible to start multiple independent browsers (Selenium Webdriver
instances) at the same time, by calling `Open Browser` or
`Create WebDriver` multiple times. These browsers are usually
independent of each other and do not share data like cookies,
sessions or profiles. Typically when the browser starts, it
creates a single window which is shown to the user.

== Window ==

Windows are the part of a browser that loads the web site and presents
it to the user. All content of the site is the content of the window.
Windows are children of a browser. In SeleniumLibrary browser is a
synonym for WebDriver instance. One browser may have multiple
windows. Windows can appear as tabs, as separate windows or pop-ups with
different position and size. Windows belonging to the same browser
typically share the sessions detail, like cookies. If there is a
need to separate sessions detail, example login with two different
users, two browsers (Selenium WebDriver instances) must be created.
New windows can be opened example by the application under test or
by example `Execute Javascript` keyword:

| `Execute Javascript`    window.open()    # Opens a new window with location about:blank

The example below opens multiple browsers and windows,
to demonstrate how the different keywords can be used to interact
with browsers, and windows attached to these browsers.

Structure:
| BrowserA
|            Window 1  (location=https://robotframework.org/)
|            Window 2  (location=https://robocon.io/)
|            Window 3  (location=https://github.com/robotframework/)
|
| BrowserB
|            Window 1  (location=https://github.com/)

Example:
| `Open Browser`       | https://robotframework.org         | ${BROWSER}       | alias=BrowserA   | # BrowserA with first window is opened.                                       |
| `Execute Javascript` | window.open()                      |                  |                  | # In BrowserA second window is opened.                                        |
| `Switch Window`      | locator=NEW                        |                  |                  | # Switched to second window in BrowserA                                       |
| `Go To`              | https://robocon.io                 |                  |                  | # Second window navigates to robocon site.                                    |
| `Execute Javascript` | window.open()                      |                  |                  | # In BrowserA third window is opened.                                         |
| ${handle}            | `Switch Window`                    | locator=NEW      |                  | # Switched to third window in BrowserA                                        |
| `Go To`              | https://github.com/robotframework/ |                  |                  | # Third windows goes to robot framework github site.                          |
| `Open Browser`       | https://github.com                 | ${BROWSER}       | alias=BrowserB   | # BrowserB with first windows is opened.                                      |
| ${location}          | `Get Location`                     |                  |                  | # ${location} is: https://www.github.com                                      |
| `Switch Window`      | ${handle}                          | browser=BrowserA |                  | # BrowserA second windows is selected.                                        |
| ${location}          | `Get Location`                     |                  |                  | # ${location} = https://robocon.io/                                           |
| @{locations 1}       | `Get Locations`                    |                  |                  | # By default, lists locations under the currectly active browser (BrowserA).   |
| @{locations 2}       | `Get Locations`                    |  browser=ALL     |                  | # By using browser=ALL argument keyword list all locations from all browsers. |

The above example, @{locations 1} contains the following items:
https://robotframework.org/, https://robocon.io/ and
https://github.com/robotframework/'. The @{locations 2}
contains the following items: https://robotframework.org/,
https://robocon.io/, https://github.com/robotframework/'
and 'https://github.com/.

= Timeouts, waits, and delays =

This section discusses different ways how to wait for elements to
appear on web pages and to slow down execution speed otherwise.
It also explains the `time format` that can be used when setting various
timeouts, waits, and delays.

== Timeout ==

SeleniumLibrary contains various keywords that have an optional
``timeout`` argument that specifies how long these keywords should
wait for certain events or actions. These keywords include, for example,
``Wait ...`` keywords and keywords related to alerts. Additionally
`Execute Async Javascript`. Although it does not have ``timeout``,
argument, uses a timeout to define how long asynchronous JavaScript
can run.

The default timeout these keywords use can be set globally either by
using the `Set Selenium Timeout` keyword or with the ``timeout`` argument
when `importing` the library. See `time format` below for supported
timeout syntax.

== Implicit wait ==

Implicit wait specifies the maximum time how long Selenium waits when
searching for elements. It can be set by using the `Set Selenium Implicit
Wait` keyword or with the ``implicit_wait`` argument when `importing`
the library. See [https://www.seleniumhq.org/docs/04_webdriver_advanced.jsp|
Selenium documentation] for more information about this functionality.

See `time format` below for supported syntax.

== Selenium speed ==

Selenium execution speed can be slowed down globally by using `Set
Selenium speed` keyword. This functionality is designed to be used for
demonstrating or debugging purposes. Using it to make sure that elements
appear on a page is not a good idea. The above-explained timeouts
and waits should be used instead.

See `time format` below for supported syntax.

== Time format ==

All timeouts and waits can be given as numbers considered seconds
(e.g. ``0.5`` or ``42``) or in Robot Framework's time syntax
(e.g. ``1.5 seconds`` or ``1 min 30 s``). For more information about
the time syntax see the
[https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#time-format|Robot Framework User Guide].

= Run-on-failure functionality =

SeleniumLibrary has a handy feature that it can automatically execute
a keyword if any of its own keywords fails. By default, it uses the
`Capture Page Screenshot` keyword, but this can be changed either by
using the `Register Keyword To Run On Failure` keyword or with the
``run_on_failure`` argument when `importing` the library. It is
possible to use any keyword from any imported library or resource file.

The run-on-failure functionality can be disabled by using a special value
``NOTHING`` or anything considered false (see `Boolean arguments`)
such as ``NONE``.

= Boolean arguments =

Starting from 5.0 SeleniumLibrary relies on Robot Framework to perform the
boolean conversion based on keyword arguments [https://docs.python.org/3/library/typing.html|type hint].
More details in Robot Framework
[https://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#supported-conversions|user guide]

Please note SeleniumLibrary 3 and 4 did have own custom methods to covert
arguments to boolean values.

= EventFiringWebDriver =

The SeleniumLibrary offers support for
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.event_firing_webdriver.html#module-selenium.webdriver.support.event_firing_webdriver|EventFiringWebDriver].
See the Selenium and SeleniumLibrary
[https://github.com/robotframework/SeleniumLibrary/blob/master/docs/extending/extending.rst#EventFiringWebDriver|EventFiringWebDriver support]
documentation for further details.

EventFiringWebDriver is new in SeleniumLibrary 4.0

= Limitations and caveats =

== Thread support ==

SeleniumLibrary is not thread-safe. This is mainly due because the underlying
[https://github.com/SeleniumHQ/selenium/wiki/Frequently-Asked-Questions#q-is-webdriver-thread-safe|
Selenium tool is not thread-safe] within one browser/driver instance.
Because of the limitation in the Selenium side, the keywords or the
API provided by the SeleniumLibrary is not thread-safe.

= Plugins =

SeleniumLibrary offers plugins as a way to modify and add library keywords and modify some of the internal
functionality without creating a new library or hacking the source code. See
[https://github.com/robotframework/SeleniumLibrary/blob/master/docs/extending/extending.rst#Plugins|plugin API]
documentation for further details.

Plugin API is new SeleniumLibrary 4.0

= Auto closing browser =

By default browser instances created during task execution are closed
at the end of the task. This can be prevented with the ``auto_close``
argument when `importing` the library.

Value needs to be set to ``False`` or anything considered false (see `Boolean arguments`).</doc>
<tags>
</tags>
<inits>
<init name="__init__" lineno="8">
<arguments repr="*args, **kwargs">
<arg kind="VAR_POSITIONAL" required="false" repr="*args">
<name>args</name>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<doc>SeleniumLibrary can be imported with several optional arguments.

- ``timeout``:
  Default value for `timeouts` used with ``Wait ...`` keywords.
- ``implicit_wait``:
  Default value for `implicit wait` used when locating elements.
- ``run_on_failure``:
  Default action for the `run-on-failure functionality`.
- ``screenshot_root_directory``:
  Path to folder where possible screenshots are created or EMBED.
  See `Set Screenshot Directory` keyword for further details about EMBED.
  If not given, the directory where the log file is written is used.
- ``plugins``:
  Allows extending the SeleniumLibrary with external Python classes.
- ``event_firing_webdriver``:
  Class for wrapping Selenium with
  [https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.event_firing_webdriver.html#module-selenium.webdriver.support.event_firing_webdriver|EventFiringWebDriver]</doc>
<shortdoc>SeleniumLibrary can be imported with several optional arguments.</shortdoc>
</init>
</inits>
<keywords>
<kw name="Add Cookie" source="./SeleniumLibrary/keywords/cookie.py" lineno="143">
<arguments repr="name: str, value: str, path: str | None = None, domain: str | None = None, secure: bool | None = None, expiry: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="name: str">
<name>name</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: str">
<name>value</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="path: str | None = None">
<name>path</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="domain: str | None = None">
<name>domain</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="secure: bool | None = None">
<name>secure</name>
<type typedoc="boolean">bool</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="expiry: str | None = None">
<name>expiry</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Adds a cookie to your current session.

``name`` and ``value`` are required, ``path``, ``domain``, ``secure``
and ``expiry`` are optional.  Expiry supports the same formats as
the [http://robotframework.org/robotframework/latest/libraries/DateTime.html|DateTime]
library or an epoch timestamp.

Example:
| `Add Cookie` | foo | bar |                            |
| `Add Cookie` | foo | bar | domain=example.com         |
| `Add Cookie` | foo | bar | expiry=2027-09-28 16:21:35 | # Expiry as timestamp.     |
| `Add Cookie` | foo | bar | expiry=1822137695          | # Expiry as epoch seconds. |

Prior to SeleniumLibrary 3.0 setting expiry did not work.</doc>
<shortdoc>Adds a cookie to your current session.</shortdoc>
</kw>
<kw name="Add Location Strategy" source="./SeleniumLibrary/keywords/element.py" lineno="1118">
<arguments repr="strategy_name: str, strategy_keyword: str, persist: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="strategy_name: str">
<name>strategy_name</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="strategy_keyword: str">
<name>strategy_keyword</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="persist: bool = False">
<name>persist</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Adds a custom location strategy.

See `Custom locators` for information on how to create and use
custom strategies. `Remove Location Strategy` can be used to
remove a registered strategy.

Location strategies are automatically removed after leaving the
current scope by default. Setting ``persist`` to a true value (see
`Boolean arguments`) will cause the location strategy to stay
registered throughout the life of the test.</doc>
<shortdoc>Adds a custom location strategy.</shortdoc>
</kw>
<kw name="Alert Should Be Present" source="./SeleniumLibrary/keywords/alert.py" lineno="52">
<arguments repr="text: str = , action: str = ACCEPT, timeout: timedelta | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="text: str = ">
<name>text</name>
<type typedoc="string">str</type>
<default/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="action: str = ACCEPT">
<name>action</name>
<type typedoc="string">str</type>
<default>ACCEPT</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that an alert is present and by default, accepts it.

Fails if no alert is present. If ``text`` is a non-empty string,
then it is used to verify alert's message. The alert is accepted
by default, but that behavior can be controlled by using the
``action`` argument same way as with `Handle Alert`.

``timeout`` specifies how long to wait for the alert to appear.
If it is not given, the global default `timeout` is used instead.

``action`` and ``timeout`` arguments are new in SeleniumLibrary 3.0.
In earlier versions, the alert was always accepted and a timeout was
hardcoded to one second.</doc>
<shortdoc>Verifies that an alert is present and by default, accepts it.</shortdoc>
</kw>
<kw name="Alert Should Not Be Present" source="./SeleniumLibrary/keywords/alert.py" lineno="79">
<arguments repr="action: str = ACCEPT, timeout: timedelta | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="action: str = ACCEPT">
<name>action</name>
<type typedoc="string">str</type>
<default>ACCEPT</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that no alert is present.

If the alert actually exists, the ``action`` argument determines
how it should be handled. By default, the alert is accepted, but
it can be also dismissed or left open the same way as with the
`Handle Alert` keyword.

``timeout`` specifies how long to wait for the alert to appear.
By default, is not waited for the alert at all, but a custom time can
be given if alert may be delayed. See the `time format` section
for information about the syntax.

New in SeleniumLibrary 3.0.</doc>
<shortdoc>Verifies that no alert is present.</shortdoc>
</kw>
<kw name="Assign Id To Element" source="./SeleniumLibrary/keywords/element.py" lineno="222">
<arguments repr="locator: WebElement | str, id: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="id: str">
<name>id</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Assigns a temporary ``id`` to the element specified by ``locator``.

This is mainly useful if the locator is complicated and/or slow XPath
expression and it is needed multiple times. Identifier expires when
the page is reloaded.

See the `Locating elements` section for details about the locator
syntax.

Example:
| `Assign ID to Element` | //ul[@class='example' and ./li[contains(., 'Stuff')]] | my id |
| `Page Should Contain Element` | my id |</doc>
<shortdoc>Assigns a temporary ``id`` to the element specified by ``locator``.</shortdoc>
</kw>
<kw name="Attach Chrome Browser" source="./RPA/Browser/Selenium.py" lineno="1200">
<arguments repr="port: int, alias: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="port: int">
<name>port</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="alias: str | None = None">
<name>alias</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Attach to an existing instance of Chrome or Chromium.

Requires that the browser was started with the command line
option ``--remote-debugging-port=&lt;port&gt;``, where port is any
4-digit number not being used by other applications.

*Note.* The first Chrome instance on the system needs to be
started with this command line option or this won't have an effect.

That port can then be used to connect using this keyword.

Example:

| Attach Chrome Browser | port=9222 |</doc>
<shortdoc>Attach to an existing instance of Chrome or Chromium.</shortdoc>
</kw>
<kw name="Capture Element Screenshot" source="./SeleniumLibrary/keywords/screenshot.py" lineno="129">
<arguments repr="locator: WebElement | None | str, filename: str = selenium-element-screenshot-{index}.png">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="filename: str = selenium-element-screenshot-{index}.png">
<name>filename</name>
<type typedoc="string">str</type>
<default>selenium-element-screenshot-{index}.png</default>
</arg>
</arguments>
<doc>Captures a screenshot from the element identified by ``locator`` and embeds it into log file.

See `Capture Page Screenshot` for details about ``filename`` argument.
See the `Locating elements` section for details about the locator
syntax.

An absolute path to the created element screenshot is returned.

Support for capturing the screenshot from an element has limited support
among browser vendors. Please check the browser vendor driver documentation
does the browser support capturing a screenshot from an element.

New in SeleniumLibrary 3.3. Support for EMBED is new in SeleniumLibrary 4.2.

Examples:
| `Capture Element Screenshot` | id:image_id |                                |
| `Capture Element Screenshot` | id:image_id | ${OUTPUTDIR}/id_image_id-1.png |
| `Capture Element Screenshot` | id:image_id | EMBED                          |</doc>
<shortdoc>Captures a screenshot from the element identified by ``locator`` and embeds it into log file.</shortdoc>
</kw>
<kw name="Capture Page Screenshot" source="./SeleniumLibrary/keywords/screenshot.py" lineno="67">
<arguments repr="filename: str = selenium-screenshot-{index}.png">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="filename: str = selenium-screenshot-{index}.png">
<name>filename</name>
<type typedoc="string">str</type>
<default>selenium-screenshot-{index}.png</default>
</arg>
</arguments>
<doc>Takes a screenshot of the current page and embeds it into a log file.

``filename`` argument specifies the name of the file to write the
screenshot into. The directory where screenshots are saved can be
set when `importing` the library or by using the `Set Screenshot
Directory` keyword. If the directory is not configured, screenshots
are saved to the same directory where Robot Framework's log file is
written.

If ``filename`` equals to EMBED (case insensitive), then screenshot
is embedded as Base64 image to the log.html. In this case file is not
created in the filesystem.

Starting from SeleniumLibrary 1.8, if ``filename`` contains marker
``{index}``, it will be automatically replaced with an unique running
index, preventing files to be overwritten. Indices start from 1,
and how they are represented can be customized using Python's
[https://docs.python.org/3/library/string.html#format-string-syntax|
format string syntax].

An absolute path to the created screenshot file is returned or if
``filename``  equals to EMBED, word `EMBED` is returned.

Support for EMBED is new in SeleniumLibrary 4.2

Examples:
| `Capture Page Screenshot` |                                        |
| `File Should Exist`       | ${OUTPUTDIR}/selenium-screenshot-1.png |
| ${path} =                 | `Capture Page Screenshot`              |
| `File Should Exist`       | ${OUTPUTDIR}/selenium-screenshot-2.png |
| `File Should Exist`       | ${path}                                |
| `Capture Page Screenshot` | custom_name.png                        |
| `File Should Exist`       | ${OUTPUTDIR}/custom_name.png           |
| `Capture Page Screenshot` | custom_with_index_{index}.png          |
| `File Should Exist`       | ${OUTPUTDIR}/custom_with_index_1.png   |
| `Capture Page Screenshot` | formatted_index_{index:03}.png         |
| `File Should Exist`       | ${OUTPUTDIR}/formatted_index_001.png   |
| `Capture Page Screenshot` | EMBED                                  |
| `File Should Not Exist`   | EMBED                                  |</doc>
<shortdoc>Takes a screenshot of the current page and embeds it into a log file.</shortdoc>
</kw>
<kw name="Checkbox Should Be Selected" source="./SeleniumLibrary/keywords/formelement.py" lineno="44">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies checkbox ``locator`` is selected/checked.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies checkbox ``locator`` is selected/checked.</shortdoc>
</kw>
<kw name="Checkbox Should Not Be Selected" source="./SeleniumLibrary/keywords/formelement.py" lineno="58">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies checkbox ``locator`` is not selected/checked.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies checkbox ``locator`` is not selected/checked.</shortdoc>
</kw>
<kw name="Choose File" source="./SeleniumLibrary/keywords/formelement.py" lineno="216">
<arguments repr="locator: WebElement | str, file_path: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="file_path: str">
<name>file_path</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Inputs the ``file_path`` into the file input field ``locator``.

This keyword is most often used to input files into upload forms.
The keyword does not check ``file_path`` is the file or folder
available on the machine where tests are executed. If the ``file_path``
points at a file and when using Selenium Grid, Selenium will
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_remote/selenium.webdriver.remote.command.html?highlight=upload#selenium.webdriver.remote.command.Command.UPLOAD_FILE|magically],
transfer the file from the machine where the tests are executed
to the Selenium Grid node where the browser is running.
Then Selenium will send the file path, from the nodes file
system, to the browser.

That ``file_path`` is not checked, is new in SeleniumLibrary 4.0.

Example:
| `Choose File` | my_upload_field | ${CURDIR}/trades.csv |</doc>
<shortdoc>Inputs the ``file_path`` into the file input field ``locator``.</shortdoc>
</kw>
<kw name="Clear All Highlights" source="./RPA/Browser/Selenium.py" lineno="2213">
<arguments repr="">
</arguments>
<doc>Remove all highlighting made by ``Highlight Elements``.</doc>
<shortdoc>Remove all highlighting made by ``Highlight Elements``.</shortdoc>
</kw>
<kw name="Clear Element Text" source="./SeleniumLibrary/keywords/element.py" lineno="524">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Clears the value of the text-input-element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Clears the value of the text-input-element identified by ``locator``.</shortdoc>
</kw>
<kw name="Click Button" source="./SeleniumLibrary/keywords/element.py" lineno="547">
<arguments repr="locator: WebElement | str, modifier: bool | str = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="modifier: bool | str = False">
<name>modifier</name>
<type typedoc="boolean">bool</type>
<type typedoc="string">str</type>
<default>False</default>
</arg>
</arguments>
<doc>Clicks the button identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, buttons are
searched using ``id``, ``name``, and ``value``.

See the `Click Element` keyword for details about the
``modifier`` argument.

The ``modifier`` argument is new in SeleniumLibrary 3.3</doc>
<shortdoc>Clicks the button identified by ``locator``.</shortdoc>
</kw>
<kw name="Click Button When Visible" source="./RPA/Browser/Selenium.py" lineno="1317">
<arguments repr="locator: str, modifier: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="modifier: str | None = None">
<name>modifier</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Click button identified by ``locator``, once it becomes visible.

``locator`` element locator

``modifier`` press given keys while clicking the element, e.g. CTRL

Example:

| Click Button When Visible  | //button[@class="mybutton"] |</doc>
<shortdoc>Click button identified by ``locator``, once it becomes visible.</shortdoc>
</kw>
<kw name="Click Element" source="./SeleniumLibrary/keywords/element.py" lineno="617">
<arguments repr="locator: WebElement | str, modifier: bool | str = False, action_chain: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="modifier: bool | str = False">
<name>modifier</name>
<type typedoc="boolean">bool</type>
<type typedoc="string">str</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="action_chain: bool = False">
<name>action_chain</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Click the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.

The ``modifier`` argument can be used to pass
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys|Selenium Keys]
when clicking the element. The `+` can be used as a separator
for different Selenium Keys. The `CTRL` is internally translated to
the `CONTROL` key. The ``modifier`` is space and case insensitive, example
"alt" and " aLt " are supported formats to
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys.ALT|ALT key]
. If ``modifier`` does not match to Selenium Keys, keyword fails.

If ``action_chain`` argument is true, see `Boolean arguments` for more
details on how to set boolean argument, then keyword uses ActionChain
based click instead of the &lt;web_element&gt;.click() function. If both
``action_chain`` and ``modifier`` are defined, the click will be
performed using ``modifier`` and ``action_chain`` will be ignored.

Example:
| Click Element | id:button |                   | # Would click element without any modifiers.               |
| Click Element | id:button | CTRL              | # Would click element with CTLR key pressed down.          |
| Click Element | id:button | CTRL+ALT          | # Would click element with CTLR and ALT keys pressed down. |
| Click Element | id:button | action_chain=True | # Clicks the button using an Selenium  ActionChains        |

The ``modifier`` argument is new in SeleniumLibrary 3.2
The ``action_chain`` argument is new in SeleniumLibrary 4.1</doc>
<shortdoc>Click the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Click Element At Coordinates" source="./SeleniumLibrary/keywords/element.py" lineno="689">
<arguments repr="locator: WebElement | str, xoffset: int, yoffset: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xoffset: int">
<name>xoffset</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="yoffset: int">
<name>yoffset</name>
<type typedoc="integer">int</type>
</arg>
</arguments>
<doc>Click the element ``locator`` at ``xoffset/yoffset``.

The Cursor is moved and the center of the element and x/y coordinates are
calculated from that point.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Click the element ``locator`` at ``xoffset/yoffset``.</shortdoc>
</kw>
<kw name="Click Element If Visible" source="./RPA/Browser/Selenium.py" lineno="1337">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Click element if it is visible

``locator`` element locator

Example:

| Click Element If Visible | //button[@class="mybutton"] |</doc>
<shortdoc>Click element if it is visible</shortdoc>
</kw>
<kw name="Click Element When Visible" source="./RPA/Browser/Selenium.py" lineno="1296">
<arguments repr="locator: str, modifier: str | None = None, action_chain: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="modifier: str | None = None">
<name>modifier</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="action_chain: bool = False">
<name>action_chain</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Click element identified by ``locator``, once it becomes visible.

``locator`` element locator

``modifier`` press given keys while clicking the element, e.g. CTRL

``action_chain`` store action in Selenium ActionChain queue

Example:

| Click Element When Visible | q |
| Click Element When Visible | id:button | CTRL+ALT |
| Click Element When Visible | action_chain=True |</doc>
<shortdoc>Click element identified by ``locator``, once it becomes visible.</shortdoc>
</kw>
<kw name="Click Image" source="./SeleniumLibrary/keywords/element.py" lineno="571">
<arguments repr="locator: WebElement | str, modifier: bool | str = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="modifier: bool | str = False">
<name>modifier</name>
<type typedoc="boolean">bool</type>
<type typedoc="string">str</type>
<default>False</default>
</arg>
</arguments>
<doc>Clicks an image identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, images are searched
using ``id``, ``name``, ``src`` and ``alt``.

See the `Click Element` keyword for details about the
``modifier`` argument.

The ``modifier`` argument is new in SeleniumLibrary 3.3</doc>
<shortdoc>Clicks an image identified by ``locator``.</shortdoc>
</kw>
<kw name="Click Link" source="./SeleniumLibrary/keywords/element.py" lineno="596">
<arguments repr="locator: WebElement | str, modifier: bool | str = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="modifier: bool | str = False">
<name>modifier</name>
<type typedoc="boolean">bool</type>
<type typedoc="string">str</type>
<default>False</default>
</arg>
</arguments>
<doc>Clicks a link identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, links are searched
using ``id``, ``name``, ``href`` and the link text.

See the `Click Element` keyword for details about the
``modifier`` argument.

The ``modifier`` argument is new in SeleniumLibrary 3.3</doc>
<shortdoc>Clicks a link identified by ``locator``.</shortdoc>
</kw>
<kw name="Close All Browsers" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="40">
<arguments repr="">
</arguments>
<doc>Closes all open browsers and resets the browser cache.

After this keyword, new indexes returned from `Open Browser` keyword
are reset to 1.

This keyword should be used in test or suite teardown to make sure
all browsers are closed.</doc>
<shortdoc>Closes all open browsers and resets the browser cache.</shortdoc>
</kw>
<kw name="Close Browser" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="53">
<arguments repr="">
</arguments>
<doc>Closes the current browser.</doc>
<shortdoc>Closes the current browser.</shortdoc>
</kw>
<kw name="Close Window" source="./SeleniumLibrary/keywords/window.py" lineno="125">
<arguments repr="">
</arguments>
<doc>Closes currently opened and selected browser window/tab.</doc>
<shortdoc>Closes currently opened and selected browser window/tab.</shortdoc>
</kw>
<kw name="Cover Element" source="./SeleniumLibrary/keywords/element.py" lineno="474">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Will cover elements identified by ``locator`` with a blue div without breaking page layout.

See the `Locating elements` section for details about the locator
syntax.

New in SeleniumLibrary 3.3.0

Example:
|`Cover Element` | css:div#container |</doc>
<shortdoc>Will cover elements identified by ``locator`` with a blue div without breaking page layout.</shortdoc>
</kw>
<kw name="Create Webdriver" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="347">
<arguments repr="driver_name: str, alias: str | None = None, kwargs={}, **init_kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="driver_name: str">
<name>driver_name</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="alias: str | None = None">
<name>alias</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="kwargs={}">
<name>kwargs</name>
<default>{}</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**init_kwargs">
<name>init_kwargs</name>
</arg>
</arguments>
<doc>Creates an instance of Selenium WebDriver.

Like `Open Browser`, but allows passing arguments to the created
WebDriver instance directly. This keyword should only be used if
the functionality provided by `Open Browser` is not adequate.

``driver_name`` must be a WebDriver implementation name like Firefox,
Chrome, Ie, Opera, Safari, PhantomJS, or Remote.

The initialized WebDriver can be configured either with a Python
dictionary ``kwargs`` or by using keyword arguments ``**init_kwargs``.
These arguments are passed directly to WebDriver without any
processing. See [https://seleniumhq.github.io/selenium/docs/api/py/api.html|
Selenium API documentation] for details about the supported arguments.

Examples:
| # Use proxy with Firefox   |                |                              |                                      |
| ${proxy}=                  | `Evaluate`     | selenium.webdriver.Proxy()   | modules=selenium, selenium.webdriver |
| ${proxy.http_proxy}=       | `Set Variable` | localhost:8888               |                                      |
| `Create Webdriver`         | Firefox        | proxy=${proxy}               |                                      |
| # Use proxy with PhantomJS |                |                              |                                      |
| ${service args}=           | `Create List`  | --proxy=192.168.132.104:8888 |                                      |
| `Create Webdriver`         | PhantomJS      | service_args=${service args} |                                      |

Returns the index of this browser instance which can be used later to
switch back to it. Index starts from 1 and is reset back to it when
`Close All Browsers` keyword is used. See `Switch Browser` for an
example.</doc>
<shortdoc>Creates an instance of Selenium WebDriver.</shortdoc>
</kw>
<kw name="Current Frame Should Contain" source="./SeleniumLibrary/keywords/frames.py" lineno="53">
<arguments repr="text: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies that the current frame contains ``text``.

See `Page Should Contain` for an explanation about the ``loglevel``
argument.

Prior to SeleniumLibrary 3.0 this keyword was named
`Current Frame Contains`.</doc>
<shortdoc>Verifies that the current frame contains ``text``.</shortdoc>
</kw>
<kw name="Current Frame Should Not Contain" source="./SeleniumLibrary/keywords/frames.py" lineno="70">
<arguments repr="text: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies that the current frame does not contain ``text``.

See `Page Should Contain` for an explanation about the ``loglevel``
argument.</doc>
<shortdoc>Verifies that the current frame does not contain ``text``.</shortdoc>
</kw>
<kw name="Delete All Cookies" source="./SeleniumLibrary/keywords/cookie.py" lineno="57">
<arguments repr="">
</arguments>
<doc>Deletes all cookies.</doc>
<shortdoc>Deletes all cookies.</shortdoc>
</kw>
<kw name="Delete Cookie" source="./SeleniumLibrary/keywords/cookie.py" lineno="62">
<arguments repr="name">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="name">
<name>name</name>
</arg>
</arguments>
<doc>Deletes the cookie matching ``name``.

If the cookie is not found, nothing happens.</doc>
<shortdoc>Deletes the cookie matching ``name``.</shortdoc>
</kw>
<kw name="Does Alert Contain" source="./RPA/Browser/Selenium.py" lineno="1479">
<arguments repr="text: str | None = None, timeout: float | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="text: str | None = None">
<name>text</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: float | None = None">
<name>timeout</name>
<type typedoc="float">float</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Does alert contain text.

``text`` check if alert includes text, will raise ValueError is text
does not exist

Example:

| ${res} | Does Alert Contain | alert message |</doc>
<shortdoc>Does alert contain text.</shortdoc>
</kw>
<kw name="Does Alert Not Contain" source="./RPA/Browser/Selenium.py" lineno="1498">
<arguments repr="text: str | None = None, timeout: float | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="text: str | None = None">
<name>text</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: float | None = None">
<name>timeout</name>
<type typedoc="float">float</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Does alert not contain text.

``text`` check that alert does not include text, will raise ValueError if text
does exist

Example:

| ${res} | Does Alert Not Contain | unexpected message |</doc>
<shortdoc>Does alert not contain text.</shortdoc>
</kw>
<kw name="Does Element Contain" source="./RPA/Browser/Selenium.py" lineno="1548">
<arguments repr="locator: str, expected: str, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Does element contain expected text

``locator`` element locator

``expected`` expected element text

``ignore_case`` should check be case insensitive, default `False`

Example:

| ${res} | Does Element Contain | id:spec | specification complete | ignore_case=True |</doc>
<shortdoc>Does element contain expected text</shortdoc>
</kw>
<kw name="Does Frame Contain" source="./RPA/Browser/Selenium.py" lineno="1532">
<arguments repr="locator: str, text: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does frame contain expected text

``locator`` locator of the frame to check

``text`` does frame contain this text

Example:

| ${res} | Does Frame Contain | id:myframe | secret |</doc>
<shortdoc>Does frame contain expected text</shortdoc>
</kw>
<kw name="Does Location Contain" source="./RPA/Browser/Selenium.py" lineno="1640">
<arguments repr="expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does current URL contain expected

``expected`` URL should contain this

Example:

| Open Available Browser | https://robocorp.com |
| ${res} | Does Location Contain | robocorp |</doc>
<shortdoc>Does current URL contain expected</shortdoc>
</kw>
<kw name="Does Page Contain" source="./RPA/Browser/Selenium.py" lineno="1655">
<arguments repr="text: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected text

``text`` page should contain this

Example:

| Open Available Browser | https://google.com |
| ${res} | Does Page Contain | Gmail |</doc>
<shortdoc>Does page contain expected text</shortdoc>
</kw>
<kw name="Does Page Contain Button" source="./RPA/Browser/Selenium.py" lineno="1670">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected button

``locator`` element locator

Example:

| ${res} | Does Page Contain Button | search-button |</doc>
<shortdoc>Does page contain expected button</shortdoc>
</kw>
<kw name="Does Page Contain Checkbox" source="./RPA/Browser/Selenium.py" lineno="1684">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected checkbox

``locator`` element locator

Example:

| ${res} | Does Page Contain Checkbox | random-selection |</doc>
<shortdoc>Does page contain expected checkbox</shortdoc>
</kw>
<kw name="Does Page Contain Element" source="./RPA/Browser/Selenium.py" lineno="1698">
<arguments repr="locator: str, count: int | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="count: int | None = None">
<name>count</name>
<type typedoc="integer">int</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Does page contain expected element

``locator`` element locator

``count`` how many times element is expected to appear on page
by default one or more

Example:

| ${res} | Does Page Contain Element | textarea |
| ${res} | Does Page Contain Element | button | count=4 |</doc>
<shortdoc>Does page contain expected element</shortdoc>
</kw>
<kw name="Does Page Contain Image" source="./RPA/Browser/Selenium.py" lineno="1716">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected image

``locator`` element locator

Example:

| Open Available Browser | https://google.com |
| ${res} | Does Page Contain Image | Google |</doc>
<shortdoc>Does page contain expected image</shortdoc>
</kw>
<kw name="Does Page Contain Link" source="./RPA/Browser/Selenium.py" lineno="1731">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected link

``locator`` element locator

Example:

| ${res} | Does Page Contain Link | id:submit |</doc>
<shortdoc>Does page contain expected link</shortdoc>
</kw>
<kw name="Does Page Contain List" source="./RPA/Browser/Selenium.py" lineno="1745">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected list

``locator`` element locator

Example:

| ${res} | Does Page Contain List | class:selections |</doc>
<shortdoc>Does page contain expected list</shortdoc>
</kw>
<kw name="Does Page Contain Radio Button" source="./RPA/Browser/Selenium.py" lineno="1759">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected radio button

``locator`` element locator

Example:

| ${res} | Does Page Contain Radio Button | male |</doc>
<shortdoc>Does page contain expected radio button</shortdoc>
</kw>
<kw name="Does Page Contain Textfield" source="./RPA/Browser/Selenium.py" lineno="1773">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does page contain expected textfield

``locator`` element locator

Example:

| ${res} | Does Page Contain Textfield | id:address |</doc>
<shortdoc>Does page contain expected textfield</shortdoc>
</kw>
<kw name="Does Table Cell Contain" source="./RPA/Browser/Selenium.py" lineno="1820">
<arguments repr="locator: str, row: int, column: int, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="row: int">
<name>row</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="column: int">
<name>column</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does table cell contain expected text

``locator`` element locator for the table

``row`` row index starting from 1 (beginning) or -1 (from the end)

``column`` column index starting from 1 (beginning) or -1 (from the end)

``expected`` expected text in table row

Example:

| ${res} | Does Table Cell Contain | //table | 1 | 1 | Company |</doc>
<shortdoc>Does table cell contain expected text</shortdoc>
</kw>
<kw name="Does Table Column Contain" source="./RPA/Browser/Selenium.py" lineno="1842">
<arguments repr="locator: str, column: int, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="column: int">
<name>column</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does table column contain expected text

``locator`` element locator for the table

``column`` column index starting from 1 (beginning) or -1 (from the end)

``expected`` expected text in table column

Example:

| ${res} | Does Table Column Contain | //table | 1 | Nokia |</doc>
<shortdoc>Does table column contain expected text</shortdoc>
</kw>
<kw name="Does Table Contain" source="./RPA/Browser/Selenium.py" lineno="1912">
<arguments repr="locator: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does table contain expected text

``locator`` element locator

``expected`` expected text in table

Example:

| ${res} | Does Table Contain | //table | February |</doc>
<shortdoc>Does table contain expected text</shortdoc>
</kw>
<kw name="Does Table Footer Contain" source="./RPA/Browser/Selenium.py" lineno="1880">
<arguments repr="locator: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does table footer contain expected text

``locator`` element locator for the table

``expected`` expected text in table footer

Example:

| ${res} | Does Table Footer Contain | //table | Sum |</doc>
<shortdoc>Does table footer contain expected text</shortdoc>
</kw>
<kw name="Does Table Header Contain" source="./RPA/Browser/Selenium.py" lineno="1896">
<arguments repr="locator: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does table header contain expected text

``locator`` element locator for the table

``expected`` expected text in table header

Example:

| ${res} | Does Table Header Contain | //table | Month |</doc>
<shortdoc>Does table header contain expected text</shortdoc>
</kw>
<kw name="Does Table Row Contain" source="./RPA/Browser/Selenium.py" lineno="1862">
<arguments repr="locator: str, row: int, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="row: int">
<name>row</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does table row contain expected text

``locator`` element locator for the table

``row`` row index starting from 1 (beginning) or -1 (from the end)

``expected`` expected text in table row

Example:

| ${res} | Does Table Row Contain | //table | 1 | Company |</doc>
<shortdoc>Does table row contain expected text</shortdoc>
</kw>
<kw name="Does Textarea Contain" source="./RPA/Browser/Selenium.py" lineno="1944">
<arguments repr="locator: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does textarea contain expected text

``locator`` element locator

``expected`` expected text in textarea

Example:

| ${res} | Does Textarea Contain | //textarea | sincerely |</doc>
<shortdoc>Does textarea contain expected text</shortdoc>
</kw>
<kw name="Does Textfield Contain" source="./RPA/Browser/Selenium.py" lineno="1960">
<arguments repr="locator: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Does textfield contain expected text

``locator`` element locator

``expected`` expected text in textfield

Example:

| ${res} | Does Textfield Contain | id:lname | Last |</doc>
<shortdoc>Does textfield contain expected text</shortdoc>
</kw>
<kw name="Double Click Element" source="./SeleniumLibrary/keywords/element.py" lineno="713">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Double clicks the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Double clicks the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Drag And Drop" source="./SeleniumLibrary/keywords/element.py" lineno="753">
<arguments repr="locator: WebElement | str, target: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="target: WebElement | str">
<name>target</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Drags the element identified by ``locator`` into the ``target`` element.

The ``locator`` argument is the locator of the dragged element
and the ``target`` is the locator of the target. See the
`Locating elements` section for details about the locator syntax.

Example:
| `Drag And Drop` | css:div#element | css:div.target |</doc>
<shortdoc>Drags the element identified by ``locator`` into the ``target`` element.</shortdoc>
</kw>
<kw name="Drag And Drop By Offset" source="./SeleniumLibrary/keywords/element.py" lineno="775">
<arguments repr="locator: WebElement | str, xoffset: int, yoffset: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="xoffset: int">
<name>xoffset</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="yoffset: int">
<name>yoffset</name>
<type typedoc="integer">int</type>
</arg>
</arguments>
<doc>Drags the element identified with ``locator`` by ``xoffset/yoffset``.

See the `Locating elements` section for details about the locator
syntax.

The element will be moved by ``xoffset`` and ``yoffset``, each of which
is a negative or positive number specifying the offset.

Example:
| `Drag And Drop By Offset` | myElem | 50 | -35 | # Move myElem 50px right and 35px down |</doc>
<shortdoc>Drags the element identified with ``locator`` by ``xoffset/yoffset``.</shortdoc>
</kw>
<kw name="Element Attribute Value Should Be" source="./SeleniumLibrary/keywords/element.py" lineno="414">
<arguments repr="locator: WebElement | str, attribute: str, expected: None | str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="attribute: str">
<name>attribute</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: None | str">
<name>expected</name>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies element identified by ``locator`` contains expected attribute value.

See the `Locating elements` section for details about the locator
syntax.

Example:
`Element Attribute Value Should Be` | css:img | href | value

New in SeleniumLibrary 3.2.</doc>
<shortdoc>Verifies element identified by ``locator`` contains expected attribute value.</shortdoc>
</kw>
<kw name="Element Should Be Disabled" source="./SeleniumLibrary/keywords/element.py" lineno="241">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies that element identified by ``locator`` is disabled.

This keyword considers also elements that are read-only to be
disabled.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies that element identified by ``locator`` is disabled.</shortdoc>
</kw>
<kw name="Element Should Be Enabled" source="./SeleniumLibrary/keywords/element.py" lineno="254">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies that element identified by ``locator`` is enabled.

This keyword considers also elements that are read-only to be
disabled.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies that element identified by ``locator`` is enabled.</shortdoc>
</kw>
<kw name="Element Should Be Focused" source="./SeleniumLibrary/keywords/element.py" lineno="267">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies that element identified by ``locator`` is focused.

See the `Locating elements` section for details about the locator
syntax.

New in SeleniumLibrary 3.0.</doc>
<shortdoc>Verifies that element identified by ``locator`` is focused.</shortdoc>
</kw>
<kw name="Element Should Be Visible" source="./SeleniumLibrary/keywords/element.py" lineno="284">
<arguments repr="locator: WebElement | str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that the element identified by ``locator`` is visible.

Herein, visible means that the element is logically visible, not
optically visible in the current browser viewport. For example,
an element that carries ``display:none`` is not logically visible,
so using this keyword on that element would fail.

See the `Locating elements` section for details about the locator
syntax.

The ``message`` argument can be used to override the default error
message.</doc>
<shortdoc>Verifies that the element identified by ``locator`` is visible.</shortdoc>
</kw>
<kw name="Element Should Contain" source="./SeleniumLibrary/keywords/element.py" lineno="55">
<arguments repr="locator: WebElement | str, expected: None | str, message: str | None = None, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: None | str">
<name>expected</name>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Verifies that element ``locator`` contains text ``expected``.

See the `Locating elements` section for details about the locator
syntax.

The ``message`` argument can be used to override the default error
message.

The ``ignore_case`` argument can be set to True to compare case
insensitive, default is False. New in SeleniumLibrary 3.1.

``ignore_case`` argument is new in SeleniumLibrary 3.1.

Use `Element Text Should Be` if you want to match the exact text,
not a substring.</doc>
<shortdoc>Verifies that element ``locator`` contains text ``expected``.</shortdoc>
</kw>
<kw name="Element Should Not Be Visible" source="./SeleniumLibrary/keywords/element.py" lineno="307">
<arguments repr="locator: WebElement | str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that the element identified by ``locator`` is NOT visible.

Passes if the element does not exists. See `Element Should Be Visible`
for more information about visibility and supported arguments.</doc>
<shortdoc>Verifies that the element identified by ``locator`` is NOT visible.</shortdoc>
</kw>
<kw name="Element Should Not Contain" source="./SeleniumLibrary/keywords/element.py" lineno="93">
<arguments repr="locator: WebElement | str, expected: None | str, message: str | None = None, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: None | str">
<name>expected</name>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Verifies that element ``locator`` does not contain text ``expected``.

See the `Locating elements` section for details about the locator
syntax.

The ``message`` argument can be used to override the default error
message.

The ``ignore_case`` argument can be set to True to compare case
insensitive, default is False.

``ignore_case`` argument new in SeleniumLibrary 3.1.</doc>
<shortdoc>Verifies that element ``locator`` does not contain text ``expected``.</shortdoc>
</kw>
<kw name="Element Text Should Be" source="./SeleniumLibrary/keywords/element.py" lineno="326">
<arguments repr="locator: WebElement | str, expected: None | str, message: str | None = None, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: None | str">
<name>expected</name>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Verifies that element ``locator`` contains exact the text ``expected``.

See the `Locating elements` section for details about the locator
syntax.

The ``message`` argument can be used to override the default error
message.

The ``ignore_case`` argument can be set to True to compare case
insensitive, default is False.

``ignore_case`` argument is new in SeleniumLibrary 3.1.

Use `Element Should Contain` if a substring match is desired.</doc>
<shortdoc>Verifies that element ``locator`` contains exact the text ``expected``.</shortdoc>
</kw>
<kw name="Element Text Should Not Be" source="./SeleniumLibrary/keywords/element.py" lineno="362">
<arguments repr="locator: WebElement | str, not_expected: None | str, message: str | None = None, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="not_expected: None | str">
<name>not_expected</name>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Verifies that element ``locator`` does not contain exact the text ``not_expected``.

See the `Locating elements` section for details about the locator
syntax.

The ``message`` argument can be used to override the default error
message.

The ``ignore_case`` argument can be set to True to compare case
insensitive, default is False.

New in SeleniumLibrary 3.1.1</doc>
<shortdoc>Verifies that element ``locator`` does not contain exact the text ``not_expected``.</shortdoc>
</kw>
<kw name="Execute Async Javascript" source="./SeleniumLibrary/keywords/javascript.py" lineno="76">
<arguments repr="*code: WebElement | str">
<arg kind="VAR_POSITIONAL" required="false" repr="*code: WebElement | str">
<name>code</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Executes asynchronous JavaScript code with possible arguments.

Similar to `Execute Javascript` except that scripts executed with
this keyword must explicitly signal they are finished by invoking the
provided callback. This callback is always injected into the executed
function as the last argument.

Scripts must complete within the script timeout or this keyword will
fail. See the `Timeout` section for more information.

Starting from SeleniumLibrary 3.2 it is possible to provide JavaScript
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_remote/selenium.webdriver.remote.webdriver.html#selenium.webdriver.remote.webdriver.WebDriver.execute_async_script|
arguments] as part of ``code`` argument. See `Execute Javascript` for
more details.

Examples:
| `Execute Async JavaScript` | var callback = arguments[arguments.length - 1]; window.setTimeout(callback, 2000); |
| `Execute Async JavaScript` | ${CURDIR}/async_js_to_execute.js |
| ${result} = | `Execute Async JavaScript`                      |
| ...         | var callback = arguments[arguments.length - 1]; |
| ...         | function answer(){callback("text");};           |
| ...         | window.setTimeout(answer, 2000);                |
| `Should Be Equal` | ${result} | text |</doc>
<shortdoc>Executes asynchronous JavaScript code with possible arguments.</shortdoc>
</kw>
<kw name="Execute Cdp" source="./RPA/Browser/Selenium.py" lineno="2268">
<arguments repr="command, parameters">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="command">
<name>command</name>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="parameters">
<name>parameters</name>
</arg>
</arguments>
<doc>Executes Chrome DevTools Protocol commands

Works only with Chrome/Chromium

For more information, available commands and parameters, see:
https://chromedevtools.github.io/devtools-protocol/

``command`` command to execute as string

``parameters`` parameters for command as a dictionary

Example:

| Open Chrome Browser | about:blank | headless=True |
| &amp;{params} | Create Dictionary | useragent=Chrome/83.0.4103.53 |
| Execute CDP | Network.setUserAgentOverride | ${params} |
| Go To | https://robocorp.com |</doc>
<shortdoc>Executes Chrome DevTools Protocol commands</shortdoc>
</kw>
<kw name="Execute Javascript" source="./SeleniumLibrary/keywords/javascript.py" lineno="33">
<arguments repr="*code: WebElement | str">
<arg kind="VAR_POSITIONAL" required="false" repr="*code: WebElement | str">
<name>code</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Executes the given JavaScript code with possible arguments.

``code`` may be divided into multiple cells in the test data and
``code`` may contain multiple lines of code and arguments. In that case,
the JavaScript code parts are concatenated together without adding
spaces and optional arguments are separated from ``code``.

If ``code`` is a path to an existing file, the JavaScript
to execute will be read from that file. Forward slashes work as
a path separator on all operating systems.

The JavaScript executes in the context of the currently selected
frame or window as the body of an anonymous function. Use ``window``
to refer to the window of your application and ``document`` to refer
to the document object of the current frame or window, e.g.
``document.getElementById('example')``.

This keyword returns whatever the executed JavaScript code returns.
Return values are converted to the appropriate Python types.

Starting from SeleniumLibrary 3.2 it is possible to provide JavaScript
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_remote/selenium.webdriver.remote.webdriver.html#selenium.webdriver.remote.webdriver.WebDriver.execute_script|
arguments] as part of ``code`` argument. The JavaScript code and
arguments must be separated with `JAVASCRIPT` and `ARGUMENTS` markers
and must be used exactly with this format. If the Javascript code is
first, then the `JAVASCRIPT` marker is optional. The order of
`JAVASCRIPT` and `ARGUMENTS` markers can be swapped, but if `ARGUMENTS`
is the first marker, then `JAVASCRIPT` marker is mandatory. It is only
allowed to use `JAVASCRIPT` and `ARGUMENTS` markers only one time in the
``code`` argument.

Examples:
| `Execute JavaScript` | window.myFunc('arg1', 'arg2') |
| `Execute JavaScript` | ${CURDIR}/js_to_execute.js    |
| `Execute JavaScript` | alert(arguments[0]); | ARGUMENTS | 123 |
| `Execute JavaScript` | ARGUMENTS | 123 | JAVASCRIPT | alert(arguments[0]); |</doc>
<shortdoc>Executes the given JavaScript code with possible arguments.</shortdoc>
</kw>
<kw name="Frame Should Contain" source="./SeleniumLibrary/keywords/frames.py" lineno="84">
<arguments repr="locator: WebElement | str, text: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies that frame identified by ``locator`` contains ``text``.

See the `Locating elements` section for details about the locator
syntax.

See `Page Should Contain` for an explanation about the ``loglevel``
argument.</doc>
<shortdoc>Verifies that frame identified by ``locator`` contains ``text``.</shortdoc>
</kw>
<kw name="Get All Links" source="./SeleniumLibrary/keywords/element.py" lineno="993">
<arguments repr="">
</arguments>
<doc>Returns a list containing ids of all links found in current page.

If a link has no id, an empty string will be in the list instead.</doc>
<shortdoc>Returns a list containing ids of all links found in current page.</shortdoc>
</kw>
<kw name="Get Browser Aliases" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="459">
<arguments repr="">
</arguments>
<doc>Returns aliases of all active browser that has an alias as NormalizedDict.
The dictionary contains the aliases as keys and the index as value.
This can be accessed as dictionary ``${aliases.key}`` or as list ``@{aliases}[0]``.

Example:
| `Open Browser` | https://example.com   | alias=BrowserA | |
| `Open Browser` | https://example.com   | alias=BrowserB | |
| &amp;{aliases}     | `Get Browser Aliases` |                | # &amp;{aliases} = { BrowserA=1|BrowserB=2 } |
| `Log`          | ${aliases.BrowserA}   |                | # logs ``1`` |
| FOR            | ${alias}              | IN             | @{aliases} |
|                | `Log`                 | ${alias}       | # logs ``BrowserA`` and ``BrowserB`` |
| END            |                       |                | |

See `Switch Browser` for more information and examples.

New in SeleniumLibrary 4.0</doc>
<shortdoc>Returns aliases of all active browser that has an alias as NormalizedDict. The dictionary contains the aliases as keys and the index as value. This can be accessed as dictionary ``${aliases.key}`` or as list ``@{aliases}[0]``.</shortdoc>
</kw>
<kw name="Get Browser Capabilities" source="./RPA/Browser/Selenium.py" lineno="2079">
<arguments repr="">
</arguments>
<doc>Get dictionary of browser properties

Example:

| ${caps}= | Get Browser Capabilities |</doc>
<shortdoc>Get dictionary of browser properties</shortdoc>
</kw>
<kw name="Get Browser Ids" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="442">
<arguments repr="">
</arguments>
<doc>Returns index of all active browser as list.

Example:
| @{browser_ids}= | Get Browser Ids   |                   |                |
| FOR             | ${id}             | IN                | @{browser_ids} |
|                 | @{window_titles}= | Get Window Titles | browser=${id}  |
|                 | Log               | Browser ${id} has these windows: ${window_titles} | |
| END             |                   |                   |                |

See `Switch Browser` for more information and examples.

New in SeleniumLibrary 4.0</doc>
<shortdoc>Returns index of all active browser as list.</shortdoc>
</kw>
<kw name="Get Cookie" source="./SeleniumLibrary/keywords/cookie.py" lineno="97">
<arguments repr="name: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="name: str">
<name>name</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns information of cookie with ``name`` as an object.

If no cookie is found with ``name``, keyword fails. The cookie object
contains details about the cookie. Attributes available in the object
are documented in the table below.

| = Attribute = |             = Explanation =                                |
| name          | The name of a cookie.                                      |
| value         | Value of the cookie.                                       |
| path          | Indicates a URL path, for example ``/``.                   |
| domain        | The domain, the cookie is visible to.                      |
| secure        | When true, the cookie is only used with HTTPS connections. |
| httpOnly      | When true, the cookie is not accessible via JavaScript.    |
| expiry        | Python datetime object indicating when the cookie expires. |
| extra         | Possible attributes outside of the WebDriver specification |

See the
[https://w3c.github.io/webdriver/#cookies|WebDriver specification]
for details about the cookie information.
Notice that ``expiry`` is specified as a
[https://docs.python.org/3/library/datetime.html#datetime.datetime|datetime object],
not as seconds since Unix Epoch like WebDriver natively does.

In some cases, example when running a browser in the cloud, it is possible that
the cookie contains other attributes than is defined in the
[https://w3c.github.io/webdriver/#cookies|WebDriver specification].
These other attributes are available in an ``extra`` attribute in the cookie
object and it contains a dictionary of the other attributes. The ``extra``
attribute is new in SeleniumLibrary 4.0.

Example:
| `Add Cookie`      | foo             | bar |
| ${cookie} =       | `Get Cookie`    | foo |
| `Should Be Equal` | ${cookie.name}  | foo |
| `Should Be Equal` | ${cookie.value} | bar |
| `Should Be True`  | ${cookie.expiry.year} &gt; 2017 |

New in SeleniumLibrary 3.0.</doc>
<shortdoc>Returns information of cookie with ``name`` as an object.</shortdoc>
</kw>
<kw name="Get Cookies" source="./SeleniumLibrary/keywords/cookie.py" lineno="70">
<arguments repr="as_dict: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="as_dict: bool = False">
<name>as_dict</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Returns all cookies of the current page.

If ``as_dict`` argument evaluates as false, see `Boolean arguments`
for more details, then cookie information is returned as
a single string in format ``name1=value1; name2=value2; name3=value3``.
When ``as_dict`` argument evaluates as true, cookie information
is returned as Robot Framework dictionary format. The string format
can be used, for example, for logging purposes or in headers when
sending HTTP requests. The dictionary format is helpful when
the result can be passed to requests library's Create Session
keyword's optional cookies parameter.

The `` as_dict`` argument is new in SeleniumLibrary 3.3</doc>
<shortdoc>Returns all cookies of the current page.</shortdoc>
</kw>
<kw name="Get Element Attribute" source="./SeleniumLibrary/keywords/element.py" lineno="396">
<arguments repr="locator: WebElement | str, attribute: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="attribute: str">
<name>attribute</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the value of ``attribute`` from the element ``locator``.

See the `Locating elements` section for details about the locator
syntax.

Example:
| ${id}= | `Get Element Attribute` | css:h1 | id |

Passing attribute name as part of the ``locator`` was removed
in SeleniumLibrary 3.2. The explicit ``attribute`` argument
should be used instead.</doc>
<shortdoc>Returns the value of ``attribute`` from the element ``locator``.</shortdoc>
</kw>
<kw name="Get Element Count" source="./SeleniumLibrary/keywords/element.py" lineno="1102">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the number of elements matching ``locator``.

If you wish to assert the number of matching elements, use
`Page Should Contain Element` with ``limit`` argument. Keyword will
always return an integer.

Example:
| ${count} =       | `Get Element Count` | name:div_name  |
| `Should Be True` | ${count} &gt; 2        |                |

New in SeleniumLibrary 3.0.</doc>
<shortdoc>Returns the number of elements matching ``locator``.</shortdoc>
</kw>
<kw name="Get Element Size" source="./SeleniumLibrary/keywords/element.py" lineno="459">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns width and height of the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.

Both width and height are returned as integers.

Example:
| ${width} | ${height} = | `Get Element Size` | css:div#container |</doc>
<shortdoc>Returns width and height of the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Get Element Status" source="./RPA/Browser/Selenium.py" lineno="2022">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Return dictionary containing element status of:

    - visible
    - enabled
    - disabled
    - focused

``locator`` element locator

Example:

| &amp;{res}  | Get Element Status | class:special |
| Log     | ${res.visible} |
| Log     | ${res.enabled} |
| Log     | ${res.disabled} |
| Log     | ${res.focused} |</doc>
<shortdoc>Return dictionary containing element status of:</shortdoc>
</kw>
<kw name="Get Horizontal Position" source="./SeleniumLibrary/keywords/element.py" lineno="445">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the horizontal position of the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.

The position is returned in pixels off the left side of the page,
as an integer.

See also `Get Vertical Position`.</doc>
<shortdoc>Returns the horizontal position of the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Get List Items" source="./SeleniumLibrary/keywords/selectelement.py" lineno="27">
<arguments repr="locator: WebElement | str, values: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="values: bool = False">
<name>values</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Returns all labels or values of selection list ``locator``.

See the `Locating elements` section for details about the locator
syntax.

Returns visible labels by default, but values can be returned by
setting the ``values`` argument to a true value (see `Boolean
arguments`).

Example:
| ${labels} = | `Get List Items` | mylist              |             |
| ${values} = | `Get List Items` | css:#example select | values=True |

Support to return values is new in SeleniumLibrary 3.0.</doc>
<shortdoc>Returns all labels or values of selection list ``locator``.</shortdoc>
</kw>
<kw name="Get Location" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="498">
<arguments repr="">
</arguments>
<doc>Returns the current browser window URL.</doc>
<shortdoc>Returns the current browser window URL.</shortdoc>
</kw>
<kw name="Get Locations" source="./SeleniumLibrary/keywords/window.py" lineno="166">
<arguments repr="browser: str = CURRENT">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser: str = CURRENT">
<name>browser</name>
<type typedoc="string">str</type>
<default>CURRENT</default>
</arg>
</arguments>
<doc>Returns and logs URLs of all windows of the selected browser.

*Browser Scope:*

The ``browser`` argument specifies the browser that shall return
its windows information.

- ``browser`` can be ``index_or_alias`` like in `Switch Browser`.

- If ``browser`` is ``CURRENT`` (default, case-insensitive)
  the currently active browser is selected.

- If ``browser`` is ``ALL`` (case-insensitive)
  the window information of all windows of all opened browsers are returned.</doc>
<shortdoc>Returns and logs URLs of all windows of the selected browser.</shortdoc>
</kw>
<kw name="Get Selected List Label" source="./SeleniumLibrary/keywords/selectelement.py" lineno="52">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the label of selected option from selection list ``locator``.

If there are multiple selected options, the label of the first option
is returned.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Returns the label of selected option from selection list ``locator``.</shortdoc>
</kw>
<kw name="Get Selected List Labels" source="./SeleniumLibrary/keywords/selectelement.py" lineno="65">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns labels of selected options from selection list ``locator``.

Starting from SeleniumLibrary 3.0, returns an empty list if there
are no selections. In earlier versions, this caused an error.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Returns labels of selected options from selection list ``locator``.</shortdoc>
</kw>
<kw name="Get Selected List Value" source="./SeleniumLibrary/keywords/selectelement.py" lineno="78">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the value of selected option from selection list ``locator``.

If there are multiple selected options, the value of the first option
is returned.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Returns the value of selected option from selection list ``locator``.</shortdoc>
</kw>
<kw name="Get Selected List Values" source="./SeleniumLibrary/keywords/selectelement.py" lineno="91">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns values of selected options from selection list ``locator``.

Starting from SeleniumLibrary 3.0, returns an empty list if there
are no selections. In earlier versions, this caused an error.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Returns values of selected options from selection list ``locator``.</shortdoc>
</kw>
<kw name="Get Selenium Implicit Wait" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="620">
<arguments repr="">
</arguments>
<doc>Gets the implicit wait value used by Selenium.

The value is returned as a human-readable string like ``1 second``.

See the `Implicit wait` section above for more information.</doc>
<shortdoc>Gets the implicit wait value used by Selenium.</shortdoc>
</kw>
<kw name="Get Selenium Speed" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="600">
<arguments repr="">
</arguments>
<doc>Gets the delay that is waited after each Selenium command.

The value is returned as a human-readable string like ``1 second``.

See the `Selenium Speed` section above for more information.</doc>
<shortdoc>Gets the delay that is waited after each Selenium command.</shortdoc>
</kw>
<kw name="Get Selenium Timeout" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="610">
<arguments repr="">
</arguments>
<doc>Gets the timeout that is used by various keywords.

The value is returned as a human-readable string like ``1 second``.

See the `Timeout` section above for more information.</doc>
<shortdoc>Gets the timeout that is used by various keywords.</shortdoc>
</kw>
<kw name="Get Session Id" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="480">
<arguments repr="">
</arguments>
<doc>Returns the currently active browser session id.

New in SeleniumLibrary 3.2</doc>
<shortdoc>Returns the currently active browser session id.</shortdoc>
</kw>
<kw name="Get Source" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="488">
<arguments repr="">
</arguments>
<doc>Returns the entire HTML source of the current page or frame.</doc>
<shortdoc>Returns the entire HTML source of the current page or frame.</shortdoc>
</kw>
<kw name="Get Table Cell" source="./SeleniumLibrary/keywords/tableelement.py" lineno="26">
<arguments repr="locator: WebElement | None | str, row: int, column: int, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="row: int">
<name>row</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="column: int">
<name>column</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Returns contents of a table cell.

The table is located using the ``locator`` argument and its cell
found using ``row`` and ``column``. See the `Locating elements`
section for details about the locator syntax.

Both row and column indexes start from 1, and header and footer
rows are included in the count. It is possible to refer to rows
and columns from the end by using negative indexes so that -1
is the last row/column, -2 is the second last, and so on.

All ``&lt;th&gt;`` and ``&lt;td&gt;`` elements anywhere in the table are
considered to be cells.

See `Page Should Contain` for an explanation about the ``loglevel``
argument.</doc>
<shortdoc>Returns contents of a table cell.</shortdoc>
</kw>
<kw name="Get Testability Status" source="./RPA/Browser/Selenium.py" lineno="2049">
<arguments repr="">
</arguments>
<doc>Get SeleniumTestability plugin status</doc>
<shortdoc>Get SeleniumTestability plugin status</shortdoc>
</kw>
<kw name="Get Text" source="./SeleniumLibrary/keywords/element.py" lineno="515">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the text value of the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Returns the text value of the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Get Title" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="493">
<arguments repr="">
</arguments>
<doc>Returns the title of the current page.</doc>
<shortdoc>Returns the title of the current page.</shortdoc>
</kw>
<kw name="Get Value" source="./SeleniumLibrary/keywords/element.py" lineno="506">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the value attribute of the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Returns the value attribute of the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Get Vertical Position" source="./SeleniumLibrary/keywords/element.py" lineno="533">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the vertical position of the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.

The position is returned in pixels off the top of the page,
as an integer.

See also `Get Horizontal Position`.</doc>
<shortdoc>Returns the vertical position of the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Get WebElement" source="./SeleniumLibrary/keywords/element.py" lineno="33">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns the first WebElement matching the given ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Returns the first WebElement matching the given ``locator``.</shortdoc>
</kw>
<kw name="Get WebElements" source="./SeleniumLibrary/keywords/element.py" lineno="42">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Returns a list of WebElement objects matching the ``locator``.

See the `Locating elements` section for details about the locator
syntax.

Starting from SeleniumLibrary 3.0, the keyword returns an empty
list if there are no matching elements. In previous releases, the
keyword failed in this case.</doc>
<shortdoc>Returns a list of WebElement objects matching the ``locator``.</shortdoc>
</kw>
<kw name="Get Window Handles" source="./SeleniumLibrary/keywords/window.py" lineno="130">
<arguments repr="browser: str = CURRENT">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser: str = CURRENT">
<name>browser</name>
<type typedoc="string">str</type>
<default>CURRENT</default>
</arg>
</arguments>
<doc>Returns all child window handles of the selected browser as a list.

Can be used as a list of windows to exclude with `Select Window`.

How to select the ``browser`` scope of this keyword, see `Get Locations`.

Prior to SeleniumLibrary 3.0, this keyword was named `List Windows`.</doc>
<shortdoc>Returns all child window handles of the selected browser as a list.</shortdoc>
</kw>
<kw name="Get Window Identifiers" source="./SeleniumLibrary/keywords/window.py" lineno="142">
<arguments repr="browser: str = CURRENT">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser: str = CURRENT">
<name>browser</name>
<type typedoc="string">str</type>
<default>CURRENT</default>
</arg>
</arguments>
<doc>Returns and logs id attributes of all windows of the selected browser.

How to select the ``browser`` scope of this keyword, see `Get Locations`.</doc>
<shortdoc>Returns and logs id attributes of all windows of the selected browser.</shortdoc>
</kw>
<kw name="Get Window Names" source="./SeleniumLibrary/keywords/window.py" lineno="150">
<arguments repr="browser: str = CURRENT">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser: str = CURRENT">
<name>browser</name>
<type typedoc="string">str</type>
<default>CURRENT</default>
</arg>
</arguments>
<doc>Returns and logs names of all windows of the selected browser.

How to select the ``browser`` scope of this keyword, see `Get Locations`.</doc>
<shortdoc>Returns and logs names of all windows of the selected browser.</shortdoc>
</kw>
<kw name="Get Window Position" source="./SeleniumLibrary/keywords/window.py" lineno="256">
<arguments repr="">
</arguments>
<doc>Returns current window position.

The position is relative to the top left corner of the screen. Returned
values are integers. See also `Set Window Position`.

Example:
| ${x} | ${y}= | `Get Window Position` |</doc>
<shortdoc>Returns current window position.</shortdoc>
</kw>
<kw name="Get Window Size" source="./SeleniumLibrary/keywords/window.py" lineno="190">
<arguments repr="inner: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="inner: bool = False">
<name>inner</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Returns current window width and height as integers.

See also `Set Window Size`.

If ``inner`` parameter is set to True, keyword returns
HTML DOM window.innerWidth and window.innerHeight properties.
See `Boolean arguments` for more details on how to set boolean
arguments. The ``inner`` is new in SeleniumLibrary 4.0.

Example:
| ${width} | ${height}= | `Get Window Size` |      |
| ${width} | ${height}= | `Get Window Size` | True |</doc>
<shortdoc>Returns current window width and height as integers.</shortdoc>
</kw>
<kw name="Get Window Titles" source="./SeleniumLibrary/keywords/window.py" lineno="158">
<arguments repr="browser: str = CURRENT">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser: str = CURRENT">
<name>browser</name>
<type typedoc="string">str</type>
<default>CURRENT</default>
</arg>
</arguments>
<doc>Returns and logs titles of all windows of the selected browser.

How to select the ``browser`` scope of this keyword, see `Get Locations`.</doc>
<shortdoc>Returns and logs titles of all windows of the selected browser.</shortdoc>
</kw>
<kw name="Go Back" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="584">
<arguments repr="">
</arguments>
<doc>Simulates the user clicking the back button on their browser.</doc>
<shortdoc>Simulates the user clicking the back button on their browser.</shortdoc>
</kw>
<kw name="Go To" source="./RPA/Browser/Selenium.py" lineno="88">
<arguments repr="url: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Navigates the current browser window to the provided ``url``.</doc>
<shortdoc>Navigates the current browser window to the provided ``url``.</shortdoc>
</kw>
<kw name="Handle Alert" source="./SeleniumLibrary/keywords/alert.py" lineno="104">
<arguments repr="action: str = ACCEPT, timeout: timedelta | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="action: str = ACCEPT">
<name>action</name>
<type typedoc="string">str</type>
<default>ACCEPT</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Handles the current alert and returns its message.

By default, the alert is accepted, but this can be controlled
with the ``action`` argument that supports the following
case-insensitive values:

- ``ACCEPT``: Accept the alert i.e. press ``Ok``. Default.
- ``DISMISS``: Dismiss the alert i.e. press ``Cancel``.
- ``LEAVE``: Leave the alert open.

The ``timeout`` argument specifies how long to wait for the alert
to appear. If it is not given, the global default `timeout` is used
instead.

Examples:
| Handle Alert |                |       | # Accept alert.  |
| Handle Alert | action=DISMISS |       | # Dismiss alert. |
| Handle Alert | timeout=10 s   |       | # Use custom timeout and accept alert.  |
| Handle Alert | DISMISS        | 1 min | # Use custom timeout and dismiss alert. |
| ${message} = | Handle Alert   |       | # Accept alert and get its message.     |
| ${message} = | Handle Alert   | LEAVE | # Leave alert open and get its message. |

New in SeleniumLibrary 3.0.</doc>
<shortdoc>Handles the current alert and returns its message.</shortdoc>
</kw>
<kw name="Highlight Elements" source="./RPA/Browser/Selenium.py" lineno="2162">
<arguments repr="locator: str, width: str = 2px, style: str = dotted, color: str = blue">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="width: str = 2px">
<name>width</name>
<type typedoc="string">str</type>
<default>2px</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="style: str = dotted">
<name>style</name>
<type typedoc="string">str</type>
<default>dotted</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="color: str = blue">
<name>color</name>
<type typedoc="string">str</type>
<default>blue</default>
</arg>
</arguments>
<doc>Highlight all matching elements by locator.

Highlighting is done by adding a colored outline
around the elements with CSS styling.

``locator``  element locator
``width``    highlight outline width
``style``    highlight outline style
``color``    highlight outline color

Example:

| Highlight Elements | xpath://h2 |</doc>
<shortdoc>Highlight all matching elements by locator.</shortdoc>
</kw>
<kw name="Input Password" source="./SeleniumLibrary/keywords/formelement.py" lineno="242">
<arguments repr="locator: WebElement | str, password: str, clear: bool = True">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="password: str">
<name>password</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="clear: bool = True">
<name>clear</name>
<type typedoc="boolean">bool</type>
<default>True</default>
</arg>
</arguments>
<doc>Types the given password into the text field identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax. See `Input Text` for ``clear`` argument details.

Difference compared to `Input Text` is that this keyword does not
log the given password on the INFO level. Notice that if you use
the keyword like

| Input Password | password_field | password |

the password is shown as a normal keyword argument. A way to avoid
that is using variables like

| Input Password | password_field | ${PASSWORD} |

Please notice that Robot Framework logs all arguments using
the TRACE level and tests must not be executed using level below
DEBUG if the password should not be logged in any format.

The `clear` argument is new in SeleniumLibrary 4.0. Hiding password
logging from Selenium logs is new in SeleniumLibrary 4.2.</doc>
<shortdoc>Types the given password into the text field identified by ``locator``.</shortdoc>
</kw>
<kw name="Input Text" source="./SeleniumLibrary/keywords/formelement.py" lineno="272">
<arguments repr="locator: WebElement | str, text: str, clear: bool = True">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="clear: bool = True">
<name>clear</name>
<type typedoc="boolean">bool</type>
<default>True</default>
</arg>
</arguments>
<doc>Types the given ``text`` into the text field identified by ``locator``.

When ``clear`` is true, the input element is cleared before
the text is typed into the element. When false, the previous text
is not cleared from the element. Use `Input Password` if you
do not want the given ``text`` to be logged.

If [https://github.com/SeleniumHQ/selenium/wiki/Grid2|Selenium Grid]
is used and the ``text`` argument points to a file in the file system,
then this keyword prevents the Selenium to transfer the file to the
Selenium Grid hub. Instead, this keyword will send the ``text`` string
as is to the element. If a file should be transferred to the hub and
upload should be performed, please use `Choose File` keyword.

See the `Locating elements` section for details about the locator
syntax. See the `Boolean arguments` section how Boolean values are
handled.

Disabling the file upload the Selenium Grid node and the `clear`
argument are new in SeleniumLibrary 4.0</doc>
<shortdoc>Types the given ``text`` into the text field identified by ``locator``.</shortdoc>
</kw>
<kw name="Input Text Into Alert" source="./SeleniumLibrary/keywords/alert.py" lineno="34">
<arguments repr="text: str, action: str = ACCEPT, timeout: timedelta | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="action: str = ACCEPT">
<name>action</name>
<type typedoc="string">str</type>
<default>ACCEPT</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Types the given ``text`` into an input field in an alert.

The alert is accepted by default, but that behavior can be controlled
by using the ``action`` argument same way as with `Handle Alert`.

``timeout`` specifies how long to wait for the alert to appear.
If it is not given, the global default `timeout` is used instead.

New in SeleniumLibrary 3.0.</doc>
<shortdoc>Types the given ``text`` into an input field in an alert.</shortdoc>
</kw>
<kw name="Input Text When Element Is Visible" source="./RPA/Browser/Selenium.py" lineno="1351">
<arguments repr="locator: str, text: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Input text into locator after it has become visible.

``locator`` element locator

``text`` insert text to locator

Example:

| Input Text When Element Is Visible | //input[@id="freetext"]  | my feedback |</doc>
<shortdoc>Input text into locator after it has become visible.</shortdoc>
</kw>
<kw name="Is Alert Present" source="./RPA/Browser/Selenium.py" lineno="1459">
<arguments repr="text: str | None = None, action: str = ACCEPT">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="text: str | None = None">
<name>text</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="action: str = ACCEPT">
<name>action</name>
<type typedoc="string">str</type>
<default>ACCEPT</default>
</arg>
</arguments>
<doc>Is alert box present, which can be identified with text
and action can also be done which by default is ACCEPT.

Other possible actions are DISMISS and LEAVE.

``text`` check if alert text is matching to this, if `None`
will check if alert is present at all

``action`` possible action if alert is present, default ACCEPT

Example:

| ${res} | Is Alert Present | alert message |</doc>
<shortdoc>Is alert box present, which can be identified with text and action can also be done which by default is ACCEPT.</shortdoc>
</kw>
<kw name="Is Checkbox Selected" source="./RPA/Browser/Selenium.py" lineno="1518">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is checkbox selected

``locator`` element locator

Example:

| ${res} |  Is Checkbox Selected  | id:taxes-paid |</doc>
<shortdoc>Is checkbox selected</shortdoc>
</kw>
<kw name="Is Element Attribute Equal To" source="./RPA/Browser/Selenium.py" lineno="1439">
<arguments repr="locator: str, attribute: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="attribute: str">
<name>attribute</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is element attribute equal to expected value

``locator`` element locator

``attribute`` element attribute to check for

``expected`` is attribute value equal to this

Example:

| ${res} | Is Element Attribute Equal To | h1 | id | main |</doc>
<shortdoc>Is element attribute equal to expected value</shortdoc>
</kw>
<kw name="Is Element Disabled" source="./RPA/Browser/Selenium.py" lineno="1403">
<arguments repr="locator: str, missing_ok: bool = True">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="missing_ok: bool = True">
<name>missing_ok</name>
<type typedoc="boolean">bool</type>
<default>True</default>
</arg>
</arguments>
<doc>Is element disabled

``locator`` element locator
``missing_ok`` default True, set to False if keyword should
Fail if element does not exist

Example:

| ${res} | Is Element Disabled | //input[@type="submit"] |</doc>
<shortdoc>Is element disabled</shortdoc>
</kw>
<kw name="Is Element Enabled" source="./RPA/Browser/Selenium.py" lineno="1367">
<arguments repr="locator: str, missing_ok: bool = True">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="missing_ok: bool = True">
<name>missing_ok</name>
<type typedoc="boolean">bool</type>
<default>True</default>
</arg>
</arguments>
<doc>Is element enabled

``locator`` element locator
``missing_ok`` default True, set to False if keyword should
Fail if element does not exist

Example:

| ${res} | Is Element Enabled | input.field1 |</doc>
<shortdoc>Is element enabled</shortdoc>
</kw>
<kw name="Is Element Focused" source="./RPA/Browser/Selenium.py" lineno="1421">
<arguments repr="locator: str, missing_ok: bool = True">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="missing_ok: bool = True">
<name>missing_ok</name>
<type typedoc="boolean">bool</type>
<default>True</default>
</arg>
</arguments>
<doc>Is element focused

``locator`` element locator
``missing_ok`` default True, set to False if keyword should
Fail if element does not exist

Example:

| ${res} | Is Element Focused | //input[@id="freetext"] |</doc>
<shortdoc>Is element focused</shortdoc>
</kw>
<kw name="Is Element Text" source="./RPA/Browser/Selenium.py" lineno="1572">
<arguments repr="locator: str, expected: str, ignore_case: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ignore_case: bool = False">
<name>ignore_case</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Is element text expected

``locator`` element locator

``expected`` expected element text

``ignore_case`` should check be case insensitive, default `False`

Example:

| ${res} | Is Element Text | id:name | john doe |
| ${res} | Is Element Text | id:name | john doe | ignore_case=True |</doc>
<shortdoc>Is element text expected</shortdoc>
</kw>
<kw name="Is Element Visible" source="./RPA/Browser/Selenium.py" lineno="1385">
<arguments repr="locator: str, missing_ok: bool = True">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="missing_ok: bool = True">
<name>missing_ok</name>
<type typedoc="boolean">bool</type>
<default>True</default>
</arg>
</arguments>
<doc>Is element visible

``locator`` element locator
``missing_ok`` default True, set to False if keyword should
Fail if element does not exist

Example:

| ${res} | Is Element Visible | id:confirmation |</doc>
<shortdoc>Is element visible</shortdoc>
</kw>
<kw name="Is List Selected" source="./RPA/Browser/Selenium.py" lineno="1612">
<arguments repr="locator: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is any option selected in the

``locator`` element locator

Example:

| ${res} | Is List Selected | id:cars |</doc>
<shortdoc>Is any option selected in the</shortdoc>
</kw>
<kw name="Is List Selection" source="./RPA/Browser/Selenium.py" lineno="1596">
<arguments repr="locator: str, *expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is list selected with expected values

``locator`` element locator

``expected`` expected selected options

Example:

| ${res} | Is List Selection | id:cars | Ford |</doc>
<shortdoc>Is list selected with expected values</shortdoc>
</kw>
<kw name="Is Location" source="./RPA/Browser/Selenium.py" lineno="1627">
<arguments repr="url: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is current URL expected url

``url`` expected current URL

Example:

| Open Available Browser | https://www.robocorp.com |
| ${res} | Is Location | https://www.robocorp.com |</doc>
<shortdoc>Is current URL expected url</shortdoc>
</kw>
<kw name="Is Radio Button Selected" source="./RPA/Browser/Selenium.py" lineno="1803">
<arguments repr="group_name: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="group_name: str">
<name>group_name</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is any radio button selected in the button group

``group_name`` radio button group name

Example:

| ${res} | Is Radio Button Selected | group_name=gender |</doc>
<shortdoc>Is any radio button selected in the button group</shortdoc>
</kw>
<kw name="Is Radio Button Set To" source="./RPA/Browser/Selenium.py" lineno="1787">
<arguments repr="group_name: str, value: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="group_name: str">
<name>group_name</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: str">
<name>value</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is radio button group set to expected value

``group_name`` radio button group name

``value`` expected value

Example:

| ${res} | Is Radio Button Set To | group_name=gender | value=female |</doc>
<shortdoc>Is radio button group set to expected value</shortdoc>
</kw>
<kw name="Is Textarea Value" source="./RPA/Browser/Selenium.py" lineno="1928">
<arguments repr="locator: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is textarea matching expected value

``locator`` element locator

``expected`` expected textarea value

Example:

| ${res} | Is Textarea Value | //textarea | Yours sincerely |</doc>
<shortdoc>Is textarea matching expected value</shortdoc>
</kw>
<kw name="Is Textfield Value" source="./RPA/Browser/Selenium.py" lineno="1976">
<arguments repr="locator: str, expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is textfield value expected

``locator`` element locator

``expected`` expected textfield value

Example:

| ${res} | Is Textfield Value | id:lname | Lastname |</doc>
<shortdoc>Is textfield value expected</shortdoc>
</kw>
<kw name="Is Title" source="./RPA/Browser/Selenium.py" lineno="1992">
<arguments repr="title: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="title: str">
<name>title</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Is page title expected

``title`` expected title value

Example:

| ${res} | Is Title | Webpage title text |</doc>
<shortdoc>Is page title expected</shortdoc>
</kw>
<kw name="List Selection Should Be" source="./SeleniumLibrary/keywords/selectelement.py" lineno="104">
<arguments repr="locator: WebElement | str, *expected: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies selection list ``locator`` has ``expected`` options selected.

It is possible to give expected options both as visible labels and
as values. Starting from SeleniumLibrary 3.0, mixing labels and
values is not possible. Order of the selected options is not
validated.

If no expected options are given, validates that the list has
no selections. A more explicit alternative is using `List Should
Have No Selections`.

See the `Locating elements` section for details about the locator
syntax.

Examples:
| `List Selection Should Be` | gender    | Female          |        |
| `List Selection Should Be` | interests | Test Automation | Python |</doc>
<shortdoc>Verifies selection list ``locator`` has ``expected`` options selected.</shortdoc>
</kw>
<kw name="List Should Have No Selections" source="./SeleniumLibrary/keywords/selectelement.py" lineno="141">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies selection list ``locator`` has no options selected.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies selection list ``locator`` has no options selected.</shortdoc>
</kw>
<kw name="Location Should Be" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="503">
<arguments repr="url: str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that the current URL is exactly ``url``.

The ``url`` argument contains the exact url that should exist in browser.

The ``message`` argument can be used to override the default error
message.

``message`` argument is new in SeleniumLibrary 3.2.0.</doc>
<shortdoc>Verifies that the current URL is exactly ``url``.</shortdoc>
</kw>
<kw name="Location Should Contain" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="521">
<arguments repr="expected: str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that the current URL contains ``expected``.

The ``expected`` argument contains the expected value in url.

The ``message`` argument can be used to override the default error
message.

``message`` argument is new in SeleniumLibrary 3.2.0.</doc>
<shortdoc>Verifies that the current URL contains ``expected``.</shortdoc>
</kw>
<kw name="Log Location" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="542">
<arguments repr="">
</arguments>
<doc>Logs and returns the current browser window URL.</doc>
<shortdoc>Logs and returns the current browser window URL.</shortdoc>
</kw>
<kw name="Log Source" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="549">
<arguments repr="loglevel: str = INFO">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = INFO">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>INFO</default>
</arg>
</arguments>
<doc>Logs and returns the HTML source of the current page or frame.

The ``loglevel`` argument defines the used log level. Valid log
levels are ``WARN``, ``INFO`` (default), ``DEBUG``, ``TRACE``
and ``NONE`` (no logging).</doc>
<shortdoc>Logs and returns the HTML source of the current page or frame.</shortdoc>
</kw>
<kw name="Log Title" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="561">
<arguments repr="">
</arguments>
<doc>Logs and returns the title of the current page.</doc>
<shortdoc>Logs and returns the title of the current page.</shortdoc>
</kw>
<kw name="Maximize Browser Window" source="./SeleniumLibrary/keywords/window.py" lineno="185">
<arguments repr="">
</arguments>
<doc>Maximizes current browser window.</doc>
<shortdoc>Maximizes current browser window.</shortdoc>
</kw>
<kw name="Mouse Down" source="./SeleniumLibrary/keywords/element.py" lineno="797">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates pressing the left mouse button on the element ``locator``.

See the `Locating elements` section for details about the locator
syntax.

The element is pressed without releasing the mouse button.

See also the more specific keywords `Mouse Down On Image` and
`Mouse Down On Link`.</doc>
<shortdoc>Simulates pressing the left mouse button on the element ``locator``.</shortdoc>
</kw>
<kw name="Mouse Down On Image" source="./SeleniumLibrary/keywords/element.py" lineno="1052">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates a mouse down event on an image identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, images are searched
using ``id``, ``name``, ``src`` and ``alt``.</doc>
<shortdoc>Simulates a mouse down event on an image identified by ``locator``.</shortdoc>
</kw>
<kw name="Mouse Down On Link" source="./SeleniumLibrary/keywords/element.py" lineno="1002">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates a mouse down event on a link identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, links are searched
using ``id``, ``name``, ``href`` and the link text.</doc>
<shortdoc>Simulates a mouse down event on a link identified by ``locator``.</shortdoc>
</kw>
<kw name="Mouse Out" source="./SeleniumLibrary/keywords/element.py" lineno="816">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates moving the mouse away from the element ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Simulates moving the mouse away from the element ``locator``.</shortdoc>
</kw>
<kw name="Mouse Over" source="./SeleniumLibrary/keywords/element.py" lineno="835">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates hovering the mouse over the element ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Simulates hovering the mouse over the element ``locator``.</shortdoc>
</kw>
<kw name="Mouse Up" source="./SeleniumLibrary/keywords/element.py" lineno="849">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates releasing the left mouse button on the element ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Simulates releasing the left mouse button on the element ``locator``.</shortdoc>
</kw>
<kw name="Open Available Browser" source="./RPA/Browser/Selenium.py" lineno="632">
<arguments repr="url: str | None = None, use_profile: bool = False, headless: Any = AUTO, maximized: bool = False, browser_selection: Any = AUTO, alias: str | None = None, profile_name: str | None = None, profile_path: str | None = None, preferences: dict | None = None, proxy: str | None = None, user_agent: str | None = None, download: Any = AUTO, options: ArgOptions | str | Dict[str, str | List | Dict] | None = None, port: int | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="url: str | None = None">
<name>url</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_profile: bool = False">
<name>use_profile</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="headless: Any = AUTO">
<name>headless</name>
<type>Any</type>
<default>AUTO</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="maximized: bool = False">
<name>maximized</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser_selection: Any = AUTO">
<name>browser_selection</name>
<type>Any</type>
<default>AUTO</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="alias: str | None = None">
<name>alias</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="profile_name: str | None = None">
<name>profile_name</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="profile_path: str | None = None">
<name>profile_path</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="preferences: dict | None = None">
<name>preferences</name>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="proxy: str | None = None">
<name>proxy</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="user_agent: str | None = None">
<name>user_agent</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="download: Any = AUTO">
<name>download</name>
<type>Any</type>
<default>AUTO</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="options: ArgOptions | str | Dict[str, str | List | Dict] | None = None">
<name>options</name>
<type>ArgOptions</type>
<type typedoc="string">str</type>
<type typedoc="dictionary">Dict[str, str | List | Dict]</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="port: int | None = None">
<name>port</name>
<type typedoc="integer">int</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Attempts to open a browser on the user's device from a set of
supported browsers. Automatically downloads a corresponding webdriver
if none is already installed.

Currently supported browsers: chrome, firefox, edge, chromiumedge, safari, ie

Optionally can be given a ``url`` as the first argument,
to open the browser directly to the given page.

Returns either a generated index or a custom ``alias`` for the
browser instance. The returned value can be used to refer to that
specific browser instance in other keywords.

If the browser should start in a maximized window, this can be
enabled with the argument ``maximized``, but is disabled by default.

For certain applications it might also be required to force a
certain user-agent string for Selenium, which can be overridden
with the ``user_agent`` argument.

WebDriver creation can be customized with ``options``. This accepts a class
instance (e.g. ``ChromeOptions``), a string like
`add_argument("--incognito");set_capability("acceptInsecureCerts", True)` or
even a simple dictionary like:
`{"arguments": ["--incognito"], "capabilities": {"acceptInsecureCerts": True}}`

A custom ``port`` can be provided to start the browser without a random one.
Make sure you provide every time a unique system-available local port if you
plan to have multiple such browsers running in parallel.

For incompatible web apps designed to work in Internet Explorer only, Edge can
run in IE mode by simply setting `ie` in the ``browser_selection`` param.
Robot example: https://github.com/robocorp/example-ie-mode-edge

Example:

| Open Available Browser | https://www.robocorp.com |
| ${index}= | Open Available Browser | ${URL} | browser_selection=opera,firefox |
| Open Available Browser | ${URL} | headless=True | alias=HeadlessBrowser |
| Open Available Browser | ${URL} | options=add_argument("user-data-dir=path/to/data");add_argument("--incognito") |
| Open Available Browser | ${URL} | port=${8888} |

== Browser order ==

The default order of supported browsers is based on the operating system
and is as follows:

| Platform    | Default order                         |
| ``Windows`` | Chrome, Firefox, ChromiumEdge         |
| ``Linux``   | Chrome, Firefox, ChromiumEdge         |
| ``Darwin``  | Chrome, Firefox, ChromiumEdge, Safari |

The order can be overridden with a custom list by using the argument
``browser_selection``. The argument can be either a comma-separated
string or a list object.

Example:

| Open Available Browser | ${URL} | browser_selection=ie |

== Webdriver download ==

The library can (if requested) automatically download webdrivers
for all the supported browsers. This can be controlled with the argument
``download``.

If the value is ``False``, it will only attempt to start
webdrivers found from the system PATH.

If the value is ``True``, it will download a webdriver that matches
the current browser.

By default the argument has the value ``AUTO``, which means it
first attempts to use webdrivers found in PATH and if that fails
forces a webdriver download.

== Opening process ==

1. Parse list of preferred browser order. If not given, use values
   from above table.

2. Loop through listed browsers:

    a. Set the webdriver options for the browser.

    b. Download webdriver (if requested).

    c. Attempt to launch the webdriver and stop the loop if successful.

3. Return index/alias if webdriver was created, or raise an exception
   if no browsers were successfully opened.

== Headless mode ==

If required, the browser can also run `headless`, which means that
it does not create a visible window. Generally a headless browser is
slightly faster, but might not support all features a normal browser does.

One typical use-case for headless mode is in cloud containers,
where there is no display available. It also prevents manual interaction
with the browser, which can be either a benefit or a drawback depending on
the context.

It can be explicitly enabled or disabled with the argument ``headless``.
By default it will be disabled, unless it detects that it is running
in a Linux environment without a display, i.e. a container.

== Chrome options ==

Some features are currently available only for Chrome/Chromium.
This includes using an existing user profile. By default Selenium
uses a new profile for each session, but it can use an existing
one by enabling the ``use_profile`` argument.

If a custom profile is stored somewhere outside of the default location,
the path to the profiles directory and the name of the profile can
be controlled with ``profile_path`` and ``profile_name`` respectively. Keep in
mind that the ``profile_path`` ends usually in "Chrome", "User Data" or
"google-chrome" and the ``profile_name`` is a directory relative to
``profile_path``, usually named "Profile 1", "Profile 2" etc. (and not as your
visible name in the Chrome browser)

Examples:

| Open Available Browser | https://www.robocorp.com | use_profile=${True} |
| Open Available Browser | https://www.robocorp.com | use_profile=${True} | profile_name=Default |
| Open Available Browser | https://www.robocorp.com | use_profile=${True} | profile_name=Profile 2 |
| Open Available Browser | https://www.robocorp.com | use_profile=${True} | profile_name=Profile 1 | profile_path=path/to/custom/user_data_dir |

Profile preferences can be further overridden with the ``preferences``
argument by giving a dictionary of key/value pairs.

Chrome can additionally connect through a ``proxy``, which
should be given as either local or remote address.</doc>
<shortdoc>Attempts to open a browser on the user's device from a set of supported browsers. Automatically downloads a corresponding webdriver if none is already installed.</shortdoc>
</kw>
<kw name="Open Browser" source="./RPA/Browser/Selenium.py" lineno="95">
<arguments repr="url: str | None = None, browser: str = firefox, alias: str | None = None, remote_url: bool | str = False, desired_capabilities: dict | None | str = None, ff_profile_dir: FirefoxProfile | str | None = None, options: ArgOptions | str | Dict[str, str | List | Dict] | None = None, service_log_path: str | None = None, executable_path: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="url: str | None = None">
<name>url</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser: str = firefox">
<name>browser</name>
<type typedoc="string">str</type>
<default>firefox</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="alias: str | None = None">
<name>alias</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="remote_url: bool | str = False">
<name>remote_url</name>
<type typedoc="boolean">bool</type>
<type typedoc="string">str</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="desired_capabilities: dict | None | str = None">
<name>desired_capabilities</name>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="ff_profile_dir: FirefoxProfile | str | None = None">
<name>ff_profile_dir</name>
<type>FirefoxProfile</type>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="options: ArgOptions | str | Dict[str, str | List | Dict] | None = None">
<name>options</name>
<type>ArgOptions</type>
<type typedoc="string">str</type>
<type typedoc="dictionary">Dict[str, str | List | Dict]</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="service_log_path: str | None = None">
<name>service_log_path</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="executable_path: str | None = None">
<name>executable_path</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Opens a new browser instance to the optional ``url``.

The ``browser`` argument specifies which browser to use. The
supported browsers are listed in the table below. The browser names
are case-insensitive and some browsers have multiple supported names.

|    = Browser =    |        = Name(s) =       |
| Firefox           | firefox, ff              |
| Google Chrome     | googlechrome, chrome, gc |
| Headless Firefox  | headlessfirefox          |
| Headless Chrome   | headlesschrome           |
| Internet Explorer | internetexplorer, ie     |
| Edge              | edge                     |
| Safari            | safari                   |
| Opera             | opera                    |
| Android           | android                  |
| Iphone            | iphone                   |
| PhantomJS         | phantomjs                |
| HTMLUnit          | htmlunit                 |
| HTMLUnit with Javascript | htmlunitwithjs    |

To be able to actually use one of these browsers, you need to have
a matching Selenium browser driver available. See the
[https://github.com/robotframework/SeleniumLibrary#browser-drivers|
project documentation] for more details. Headless Firefox and
Headless Chrome are new additions in SeleniumLibrary 3.1.0
and require Selenium 3.8.0 or newer.

After opening the browser, it is possible to use optional
``url`` to navigate the browser to the desired address.

Optional ``alias`` is an alias given for this browser instance and
it can be used for switching between browsers. When same ``alias``
is given with two `Open Browser` keywords, the first keyword will
open a new browser, but the second one will switch to the already
opened browser and will not open a new browser. The ``alias``
definition overrules ``browser`` definition. When same ``alias``
is used but a different ``browser`` is defined, then switch to
a browser with same alias is done and new browser is not opened.
An alternative approach for switching is using an index returned
by this keyword. These indices start from 1, are incremented when new
browsers are opened, and reset back to 1 when `Close All Browsers`
is called. See `Switch Browser` for more information and examples.

Optional ``remote_url`` is the URL for a
[https://github.com/SeleniumHQ/selenium/wiki/Grid2|Selenium Grid].

Optional ``desired_capabilities`` can be used to configure, for example,
logging preferences for a browser or a browser and operating system
when using [http://saucelabs.com|Sauce Labs]. Desired capabilities can
be given either as a Python dictionary or as a string in the format
``key1:value1,key2:value2``.
[https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities|
Selenium documentation] lists possible capabilities that can be
enabled.

Optional ``ff_profile_dir`` is the path to the Firefox profile
directory if you wish to overwrite the default profile Selenium
uses. Notice that prior to SeleniumLibrary 3.0, the library
contained its own profile that was used by default. The
``ff_profile_dir`` can also be an instance of the
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_firefox/selenium.webdriver.firefox.firefox_profile.html|selenium.webdriver.FirefoxProfile]
. As a third option, it is possible to use `FirefoxProfile` methods
and attributes to define the profile using methods and attributes
in the same way as with ``options`` argument. Example: It is possible
to use FirefoxProfile `set_preference` to define different
profile settings. See ``options`` argument documentation in below
how to handle backslash escaping.

Optional ``options`` argument allows defining browser specific
Selenium options. Example for Chrome, the ``options`` argument
allows defining the following
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_chrome/selenium.webdriver.chrome.options.html#selenium.webdriver.chrome.options.Options|methods and attributes]
and for Firefox these
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_firefox/selenium.webdriver.firefox.options.html?highlight=firefox#selenium.webdriver.firefox.options.Options|methods and attributes]
are available. Please note that not all browsers, supported by the
SeleniumLibrary, have Selenium options available. Therefore please
consult the Selenium documentation which browsers do support
the Selenium options. If ``browser`` argument is `android` then
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_chrome/selenium.webdriver.chrome.options.html#selenium.webdriver.chrome.options.Options|Chrome options]
is used. Selenium options are also supported, when ``remote_url``
argument is used.

The SeleniumLibrary ``options`` argument accepts Selenium
options in two different formats: as a string and as Python object
which is an instance of the Selenium options class.

The string format allows defining Selenium options methods
or attributes and their arguments in Robot Framework test data.
The method and attributes names are case and space sensitive and
must match to the Selenium options methods and attributes names.
When defining a method, it must be defined in a similar way as in
python: method name, opening parenthesis, zero to many arguments
and closing parenthesis. If there is a need to define multiple
arguments for a single method, arguments must be separated with
comma, just like in Python. Example: `add_argument("--headless")`
or `add_experimental_option("key", "value")`. Attributes are
defined in a similar way as in Python: attribute name, equal sign,
and attribute value. Example, `headless=True`. Multiple methods
and attributes must be separated by a semicolon. Example:
`add_argument("--headless");add_argument("--start-maximized")`.

Arguments allow defining Python data types and arguments are
evaluated by using Python
[https://docs.python.org/3/library/ast.html#ast.literal_eval|ast.literal_eval].
Strings must be quoted with single or double quotes, example "value"
or 'value'. It is also possible to define other Python builtin
data types, example `True` or `None`, by not using quotes
around the arguments.

The string format is space friendly. Usually, spaces do not alter
the defining methods or attributes. There are two exceptions.
In some Robot Framework test data formats, two or more spaces are
considered as cell separator and instead of defining a single
argument, two or more arguments may be defined. Spaces in string
arguments are not removed and are left as is. Example
`add_argument ( "--headless" )` is same as
`add_argument("--headless")`. But `add_argument(" --headless ")` is
not same same as `add_argument ( "--headless" )`, because
spaces inside of quotes are not removed. Please note that if
options string contains backslash, example a Windows OS path,
the backslash needs escaping both in Robot Framework data and
in Python side. This means single backslash must be writen using
four backslash characters. Example, Windows path:
"C:\path\to\profile" must be written as
"C:\\\\path\\\to\\\\profile". Another way to write
backslash is use Python
[https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals|raw strings]
and example write: r"C:\\path\\to\\profile".

As last format, ``options`` argument also supports receiving
the Selenium options as Python class instance. In this case, the
instance is used as-is and the SeleniumLibrary will not convert
the instance to other formats.
For example, if the following code return value is saved to
`${options}` variable in the Robot Framework data:
| options = webdriver.ChromeOptions()
| options.add_argument('--disable-dev-shm-usage')
| return options

Then the `${options}` variable can be used as an argument to
``options``.

Example the ``options`` argument can be used to launch Chomium-based
applications which utilize the
[https://bitbucket.org/chromiumembedded/cef/wiki/UsingChromeDriver|Chromium Embedded Framework]
. To lauch Chomium-based application, use ``options`` to define
`binary_location` attribute and use `add_argument` method to define
`remote-debugging-port` port for the application. Once the browser
is opened, the test can interact with the embedded web-content of
the system under test.

Optional ``service_log_path`` argument defines the name of the
file where to write the browser driver logs. If the
``service_log_path``  argument contain a  marker ``{index}``, it
will be automatically replaced with unique running
index preventing files to be overwritten. Indices start's from 1,
and how they are represented can be customized using Python's
[https://docs.python.org/3/library/string.html#format-string-syntax|
format string syntax].

Optional ``executable_path`` argument defines the path to the driver
executable, example to a chromedriver or a geckodriver. If not defined
it is assumed the executable is in the
[https://en.wikipedia.org/wiki/PATH_(variable)|$PATH].

Examples:
| `Open Browser` | http://example.com | Chrome  |                                         |
| `Open Browser` | http://example.com | Firefox | alias=Firefox                           |
| `Open Browser` | http://example.com | Edge    | remote_url=http://127.0.0.1:4444/wd/hub |
| `Open Browser` | about:blank        |         |                                         |
| `Open Browser` | browser=Chrome     |         |                                         |

Alias examples:
| ${1_index} =    | `Open Browser` | http://example.com | Chrome  | alias=Chrome     | # Opens new browser because alias is new.         |
| ${2_index} =    | `Open Browser` | http://example.com | Firefox |                  | # Opens new browser because alias is not defined. |
| ${3_index} =    | `Open Browser` | http://example.com | Chrome  | alias=Chrome     | # Switches to the browser with Chrome alias.      |
| ${4_index} =    | `Open Browser` | http://example.com | Chrome  | alias=${1_index} | # Switches to the browser with Chrome alias.      |
| Should Be Equal | ${1_index}     | ${3_index}         |         |                  |                                                   |
| Should Be Equal | ${1_index}     | ${4_index}         |         |                  |                                                   |
| Should Be Equal | ${2_index}     | ${2}               |         |                  |                                                   |

Example when using
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_chrome/selenium.webdriver.chrome.options.html#selenium.webdriver.chrome.options.Options|Chrome options]
method:
| `Open Browser` | http://example.com | Chrome | options=add_argument("--disable-popup-blocking"); add_argument("--ignore-certificate-errors") | # Sting format.                    |
|  ${options} =  |     Get Options    |        |                                                                                               | # Selenium options instance.       |
| `Open Browser` | http://example.com | Chrome | options=${options}                                                                            |                                    |
| `Open Browser` | None               | Chrome | options=binary_location="/path/to/binary";add_argument("remote-debugging-port=port")          | # Start Chomium-based application. |
| `Open Browser` | None               | Chrome | options=binary_location=r"C:\\path\\to\\binary"                                         | # Windows OS path escaping.        |

Example for FirefoxProfile
| `Open Browser` | http://example.com | Firefox | ff_profile_dir=/path/to/profile                                                  | # Using profile from disk.                       |
| `Open Browser` | http://example.com | Firefox | ff_profile_dir=${FirefoxProfile_instance}                                        | # Using instance of FirefoxProfile.              |
| `Open Browser` | http://example.com | Firefox | ff_profile_dir=set_preference("key", "value");set_preference("other", "setting") | # Defining profile using FirefoxProfile mehtods. |

If the provided configuration options are not enough, it is possible
to use `Create Webdriver` to customize browser initialization even
more.

Applying ``desired_capabilities`` argument also for local browser is
new in SeleniumLibrary 3.1.

Using ``alias`` to decide, is the new browser opened is new
in SeleniumLibrary 4.0. The ``options`` and ``service_log_path``
are new in SeleniumLibrary 4.0. Support for ``ff_profile_dir``
accepting an instance of the `selenium.webdriver.FirefoxProfile`
and support defining FirefoxProfile with methods and
attributes are new in SeleniumLibrary 4.0.

Making ``url`` optional is new in SeleniumLibrary 4.1.

The ``executable_path`` argument is new in SeleniumLibrary 4.2.</doc>
<shortdoc>Opens a new browser instance to the optional ``url``.</shortdoc>
</kw>
<kw name="Open Chrome Browser" source="./RPA/Browser/Selenium.py" lineno="1169">
<arguments repr="url: str, use_profile: bool = False, headless: bool = False, maximized: bool = False, alias: str | None = None, profile_name: str | None = None, profile_path: str | None = None, preferences: dict | None = None, proxy: str | None = None, user_agent: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_profile: bool = False">
<name>use_profile</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="headless: bool = False">
<name>headless</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="maximized: bool = False">
<name>maximized</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="alias: str | None = None">
<name>alias</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="profile_name: str | None = None">
<name>profile_name</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="profile_path: str | None = None">
<name>profile_path</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="preferences: dict | None = None">
<name>preferences</name>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="proxy: str | None = None">
<name>proxy</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="user_agent: str | None = None">
<name>user_agent</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Open Chrome browser. See ``Open Available Browser`` for
descriptions of arguments.</doc>
<shortdoc>Open Chrome browser. See ``Open Available Browser`` for descriptions of arguments.</shortdoc>
</kw>
<kw name="Open Context Menu" source="./SeleniumLibrary/keywords/element.py" lineno="862">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Opens the context menu on the element identified by ``locator``.</doc>
<shortdoc>Opens the context menu on the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Open Headless Chrome Browser" source="./RPA/Browser/Selenium.py" lineno="1229">
<arguments repr="url: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Open Chrome browser in headless mode.

``url`` URL to open

Example:

| ${idx} | Open Headless Chrome Browser | https://www.google.com |</doc>
<shortdoc>Open Chrome browser in headless mode.</shortdoc>
</kw>
<kw name="Open User Browser" source="./RPA/Browser/Selenium.py" lineno="2054">
<arguments repr="url: str, tab=True">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="url: str">
<name>url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="tab=True">
<name>tab</name>
<default>True</default>
</arg>
</arguments>
<doc>Open URL with user's default browser

The browser opened with this keyword is not accessible
with selenium. To interact with the opened browser it is
possible to use ``Desktop`` library keywords.

The keyword `Attach Chrome Browser` can be used to
access already open browser with selenium keywords.

Read more: https://robocorp.com/docs/development-guide/browser/how-to-attach-to-running-chrome-browser

``url`` URL to open
``tab`` defines is url is opened in a tab (default `True`) or
        in new window (`False`)

Example:

| Open User Browser  | https://www.google.com?q=rpa |
| Open User Browser  | https://www.google.com?q=rpa | tab=False |</doc>
<shortdoc>Open URL with user's default browser</shortdoc>
</kw>
<kw name="Page Should Contain" source="./SeleniumLibrary/keywords/element.py" lineno="128">
<arguments repr="text: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies that current page contains ``text``.

If this keyword fails, it automatically logs the page source
using the log level specified with the optional ``loglevel``
argument. Valid log levels are ``DEBUG``, ``INFO`` (default),
``WARN``, and ``NONE``. If the log level is ``NONE`` or below
the current active log level the source will not be logged.</doc>
<shortdoc>Verifies that current page contains ``text``.</shortdoc>
</kw>
<kw name="Page Should Contain Button" source="./SeleniumLibrary/keywords/formelement.py" lineno="430">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies button ``locator`` is found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, buttons are
searched using ``id``, ``name``, and ``value``.</doc>
<shortdoc>Verifies button ``locator`` is found from current page.</shortdoc>
</kw>
<kw name="Page Should Contain Checkbox" source="./SeleniumLibrary/keywords/formelement.py" lineno="70">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies checkbox ``locator`` is found from the current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies checkbox ``locator`` is found from the current page.</shortdoc>
</kw>
<kw name="Page Should Contain Element" source="./SeleniumLibrary/keywords/element.py" lineno="145">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE, limit: int | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="limit: int | None = None">
<name>limit</name>
<type typedoc="integer">int</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that element ``locator`` is found on the current page.

See the `Locating elements` section for details about the locator
syntax.

The ``message`` argument can be used to override the default error
message.

The ``limit`` argument can used to define how many elements the
page should contain. When ``limit`` is ``None`` (default) page can
contain one or more elements. When limit is a number, page must
contain same number of elements.

See `Page Should Contain` for an explanation about the ``loglevel``
argument.

Examples assumes that locator matches to two elements.
| `Page Should Contain Element` | div_name | limit=1    | # Keyword fails.                  |
| `Page Should Contain Element` | div_name | limit=2    | # Keyword passes.                 |
| `Page Should Contain Element` | div_name | limit=none | # None is considered one or more. |
| `Page Should Contain Element` | div_name |            | # Same as above.                  |

The ``limit`` argument is new in SeleniumLibrary 3.0.</doc>
<shortdoc>Verifies that element ``locator`` is found on the current page.</shortdoc>
</kw>
<kw name="Page Should Contain Image" source="./SeleniumLibrary/keywords/element.py" lineno="1066">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies image identified by ``locator`` is found from current page.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, images are searched
using ``id``, ``name``, ``src`` and ``alt``.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.</doc>
<shortdoc>Verifies image identified by ``locator`` is found from current page.</shortdoc>
</kw>
<kw name="Page Should Contain Link" source="./SeleniumLibrary/keywords/element.py" lineno="1016">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies link identified by ``locator`` is found from current page.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, links are searched
using ``id``, ``name``, ``href`` and the link text.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.</doc>
<shortdoc>Verifies link identified by ``locator`` is found from current page.</shortdoc>
</kw>
<kw name="Page Should Contain List" source="./SeleniumLibrary/keywords/selectelement.py" lineno="159">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies selection list ``locator`` is found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies selection list ``locator`` is found from current page.</shortdoc>
</kw>
<kw name="Page Should Contain Radio Button" source="./SeleniumLibrary/keywords/formelement.py" lineno="132">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies radio button ``locator`` is found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, radio buttons are
searched using ``id``, ``name`` and ``value``.</doc>
<shortdoc>Verifies radio button ``locator`` is found from current page.</shortdoc>
</kw>
<kw name="Page Should Contain Textfield" source="./SeleniumLibrary/keywords/formelement.py" lineno="300">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies text field ``locator`` is found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies text field ``locator`` is found from current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain" source="./SeleniumLibrary/keywords/element.py" lineno="193">
<arguments repr="text: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies the current page does not contain ``text``.

See `Page Should Contain` for an explanation about the ``loglevel``
argument.</doc>
<shortdoc>Verifies the current page does not contain ``text``.</shortdoc>
</kw>
<kw name="Page Should Not Contain Button" source="./SeleniumLibrary/keywords/formelement.py" lineno="451">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies button ``locator`` is not found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, buttons are
searched using ``id``, ``name``, and ``value``.</doc>
<shortdoc>Verifies button ``locator`` is not found from current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain Checkbox" source="./SeleniumLibrary/keywords/formelement.py" lineno="87">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies checkbox ``locator`` is not found from the current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies checkbox ``locator`` is not found from the current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain Element" source="./SeleniumLibrary/keywords/element.py" lineno="205">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies that element ``locator`` is not found on the current page.

See the `Locating elements` section for details about the locator
syntax.

See `Page Should Contain` for an explanation about ``message`` and
``loglevel`` arguments.</doc>
<shortdoc>Verifies that element ``locator`` is not found on the current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain Image" source="./SeleniumLibrary/keywords/element.py" lineno="1084">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies image identified by ``locator`` is not found from current page.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, images are searched
using ``id``, ``name``, ``src`` and ``alt``.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.</doc>
<shortdoc>Verifies image identified by ``locator`` is not found from current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain Link" source="./SeleniumLibrary/keywords/element.py" lineno="1034">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies link identified by ``locator`` is not found from current page.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, links are searched
using ``id``, ``name``, ``href`` and the link text.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.</doc>
<shortdoc>Verifies link identified by ``locator`` is not found from current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain List" source="./SeleniumLibrary/keywords/selectelement.py" lineno="176">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies selection list ``locator`` is not found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies selection list ``locator`` is not found from current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain Radio Button" source="./SeleniumLibrary/keywords/formelement.py" lineno="150">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies radio button ``locator`` is not found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax. When using the default locator strategy, radio buttons are
searched using ``id``, ``name`` and ``value``.</doc>
<shortdoc>Verifies radio button ``locator`` is not found from current page.</shortdoc>
</kw>
<kw name="Page Should Not Contain Textfield" source="./SeleniumLibrary/keywords/formelement.py" lineno="317">
<arguments repr="locator: WebElement | str, message: str | None = None, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies text field ``locator`` is not found from current page.

See `Page Should Contain Element` for an explanation about ``message``
and ``loglevel`` arguments.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies text field ``locator`` is not found from current page.</shortdoc>
</kw>
<kw name="Press Key" deprecated="true" source="./SeleniumLibrary/keywords/element.py" lineno="896">
<arguments repr="locator: WebElement | str, key: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="key: str">
<name>key</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>*DEPRECATED in SeleniumLibrary 4.0.* use `Press Keys` instead.</doc>
<shortdoc>*DEPRECATED in SeleniumLibrary 4.0.* use `Press Keys` instead.</shortdoc>
</kw>
<kw name="Press Keys" source="./SeleniumLibrary/keywords/element.py" lineno="904">
<arguments repr="locator: WebElement | None | str = None, *keys: str">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="locator: WebElement | None | str = None">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
<default>None</default>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*keys: str">
<name>keys</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates the user pressing key(s) to an element or on the active browser.

If ``locator`` evaluates as false, see `Boolean arguments` for more
details, then the ``keys`` are sent to the currently active browser.
Otherwise element is searched and ``keys`` are send to the element
identified by the ``locator``. In later case, keyword fails if element
is not found. See the `Locating elements` section for details about
the locator syntax.

``keys`` arguments can contain one or many strings, but it can not
be empty. ``keys`` can also be a combination of
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html|Selenium Keys]
and strings or a single Selenium Key. If Selenium Key is combined
with strings, Selenium key and strings must be separated by the
`+` character, like in `CONTROL+c`. Selenium Keys
are space and case sensitive and Selenium Keys are not parsed
inside of the string. Example AALTO, would send string `AALTO`
and `ALT` not parsed inside of the string. But `A+ALT+O` would
found Selenium ALT key from the ``keys`` argument. It also possible
to press many Selenium Keys down at the same time, example
'ALT+ARROW_DOWN`.

If Selenium Keys are detected in the ``keys`` argument, keyword
will press the Selenium Key down, send the strings and
 then release the Selenium Key. If keyword needs to send a Selenium
Key as a string, then each character must be separated with
`+` character, example `E+N+D`.

`CTRL` is alias for
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys.CONTROL|Selenium CONTROL]
and ESC is alias for
[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys.ESCAPE|Selenium ESCAPE]

New in SeleniumLibrary 3.3

Examples:
| `Press Keys` | text_field | AAAAA          |            | # Sends string "AAAAA" to element.                                                |
| `Press Keys` | None       | BBBBB          |            | # Sends string "BBBBB" to currently active browser.                               |
| `Press Keys` | text_field | E+N+D          |            | # Sends string "END" to element.                                                  |
| `Press Keys` | text_field | XXX            | YY         | # Sends strings "XXX" and "YY" to element.                                        |
| `Press Keys` | text_field | XXX+YY         |            | # Same as above.                                                                  |
| `Press Keys` | text_field | ALT+ARROW_DOWN |            | # Pressing "ALT" key down, then pressing ARROW_DOWN and then releasing both keys. |
| `Press Keys` | text_field | ALT            | ARROW_DOWN | # Pressing "ALT" key and then pressing ARROW_DOWN.                                |
| `Press Keys` | text_field | CTRL+c         |            | # Pressing CTRL key down, sends string "c" and then releases CTRL key.            |
| `Press Keys` | button     | RETURN         |            | # Pressing "ENTER" key to element.                                                |</doc>
<shortdoc>Simulates the user pressing key(s) to an element or on the active browser.</shortdoc>
</kw>
<kw name="Print To Pdf" source="./RPA/Browser/Selenium.py" lineno="2225">
<arguments repr="output_path: str | None = None, params: dict | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="output_path: str | None = None">
<name>output_path</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="params: dict | None = None">
<name>params</name>
<type typedoc="dictionary">dict</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Print the current page to a PDF document using Chrome/Chromium DevTools.

Attention: This works in ``headless`` mode only!
For supported parameters see:
https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF
Returns the output PDF file path.

:param output_path: File path for the generated PDF document. By default, it is
    saved to the output folder with the name `out.pdf`.
:param params: Parameters for the browser printing method. By default, it uses
    the following values:
    ``{
        "landscape": False,
        "displayHeaderFooter": False,
        "printBackground": True,
        "preferCSSPageSize": True,
    }``</doc>
<shortdoc>Print the current page to a PDF document using Chrome/Chromium DevTools.</shortdoc>
</kw>
<kw name="Radio Button Should Be Set To" source="./SeleniumLibrary/keywords/formelement.py" lineno="168">
<arguments repr="group_name: str, value: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="group_name: str">
<name>group_name</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: str">
<name>value</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies radio button group ``group_name`` is set to ``value``.

``group_name`` is the ``name`` of the radio button group.</doc>
<shortdoc>Verifies radio button group ``group_name`` is set to ``value``.</shortdoc>
</kw>
<kw name="Radio Button Should Not Be Selected" source="./SeleniumLibrary/keywords/formelement.py" lineno="183">
<arguments repr="group_name: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="group_name: str">
<name>group_name</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Verifies radio button group ``group_name`` has no selection.

``group_name`` is the ``name`` of the radio button group.</doc>
<shortdoc>Verifies radio button group ``group_name`` has no selection.</shortdoc>
</kw>
<kw name="Register Keyword To Run On Failure" source="./SeleniumLibrary/keywords/runonfailure.py" lineno="23">
<arguments repr="keyword: str | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="keyword: str | None">
<name>keyword</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
</arg>
</arguments>
<doc>Sets the keyword to execute, when a SeleniumLibrary keyword fails.

``keyword`` is the name of a keyword that will be executed if a
SeleniumLibrary keyword fails. It is possible to use any available
keyword, including user keywords or keywords from other libraries,
but the keyword must not take any arguments.

The initial keyword to use is set when `importing` the library, and
the keyword that is used by default is `Capture Page Screenshot`.
Taking a screenshot when something failed is a very useful
feature, but notice that it can slow down the execution.

It is possible to use string ``NOTHING`` or ``NONE``,
case-insensitively, as well as Python ``None`` to disable this
feature altogether.

This keyword returns the name of the previously registered
failure keyword or Python ``None`` if this functionality was
previously disabled. The return value can be always used to
restore the original value later.

Example:
| `Register Keyword To Run On Failure`  | Log Source |
| ${previous kw}= | `Register Keyword To Run On Failure`  | NONE |
| `Register Keyword To Run On Failure`  | ${previous kw} |

Changes in SeleniumLibrary 3.0:
- Possible to use string ``NONE`` or Python ``None`` to disable the
  functionality.
- Return Python ``None`` when the functionality was disabled earlier.
  In previous versions special value ``No Keyword`` was returned and
  it could not be used to restore the original state.</doc>
<shortdoc>Sets the keyword to execute, when a SeleniumLibrary keyword fails.</shortdoc>
</kw>
<kw name="Reload Page" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="595">
<arguments repr="">
</arguments>
<doc>Simulates user reloading page.</doc>
<shortdoc>Simulates user reloading page.</shortdoc>
</kw>
<kw name="Remove Location Strategy" source="./SeleniumLibrary/keywords/element.py" lineno="1135">
<arguments repr="strategy_name: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="strategy_name: str">
<name>strategy_name</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Removes a previously added custom location strategy.

See `Custom locators` for information on how to create and use
custom strategies.</doc>
<shortdoc>Removes a previously added custom location strategy.</shortdoc>
</kw>
<kw name="Screenshot" source="./RPA/Browser/Selenium.py" lineno="1241">
<arguments repr="locator: str | None = None, filename: str = ">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="locator: str | None = None">
<name>locator</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="filename: str = ">
<name>filename</name>
<type typedoc="string">str</type>
<default/>
</arg>
</arguments>
<doc>Capture page and/or element screenshot.

``locator`` if defined, take element screenshot, if not takes page screenshot

``filename`` filename for the screenshot, by default creates file `screenshot-timestamp-element/page.png`
if set to `None` then file is not saved at all

Example:

| Screenshot | locator=//img[@alt="Google"] | filename=locator.png              | # element screenshot, defined filename            |
| Screenshot | filename=page.png            |                                   | # page screenshot, defined filename               |
| Screenshot | filename=${NONE}             |                                   | # page screenshot, NO file will be created        |
| Screenshot |                              |                                   | # page screenshot, default filename               |
| Screenshot | locator=//img[@alt="Google"] |                                   | # element screenshot, default filename            |
| Screenshot | locator=//img[@alt="Google"] | filename=${CURDIR}/subdir/loc.png | # element screenshot, create dirs if not existing |</doc>
<shortdoc>Capture page and/or element screenshot.</shortdoc>
</kw>
<kw name="Scroll Element Into View" source="./SeleniumLibrary/keywords/element.py" lineno="739">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Scrolls the element identified by ``locator`` into view.

See the `Locating elements` section for details about the locator
syntax.

New in SeleniumLibrary 3.2.0</doc>
<shortdoc>Scrolls the element identified by ``locator`` into view.</shortdoc>
</kw>
<kw name="Select All From List" source="./SeleniumLibrary/keywords/selectelement.py" lineno="193">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Selects all options from multi-selection list ``locator``.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Selects all options from multi-selection list ``locator``.</shortdoc>
</kw>
<kw name="Select Checkbox" source="./SeleniumLibrary/keywords/formelement.py" lineno="104">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Selects the checkbox identified by ``locator``.

Does nothing if checkbox is already selected.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Selects the checkbox identified by ``locator``.</shortdoc>
</kw>
<kw name="Select Frame" source="./SeleniumLibrary/keywords/frames.py" lineno="25">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Sets frame identified by ``locator`` as the current frame.

See the `Locating elements` section for details about the locator
syntax.

Works both with frames and iframes. Use `Unselect Frame` to cancel
the frame selection and return to the main frame.

Example:
| `Select Frame`   | top-frame | # Select frame with id or name 'top-frame'   |
| `Click Link`     | example   | # Click link 'example' in the selected frame |
| `Unselect Frame` |           | # Back to main frame.                        |
| `Select Frame`   | //iframe[@name='xxx'] | # Select frame using xpath       |</doc>
<shortdoc>Sets frame identified by ``locator`` as the current frame.</shortdoc>
</kw>
<kw name="Select From List By Index" source="./SeleniumLibrary/keywords/selectelement.py" lineno="209">
<arguments repr="locator: WebElement | str, *indexes: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*indexes: str">
<name>indexes</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Selects options from selection list ``locator`` by ``indexes``.

Indexes of list options start from 0.

If more than one option is given for a single-selection list,
the last value will be selected. With multi-selection lists all
specified options are selected, but possible old selections are
not cleared.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Selects options from selection list ``locator`` by ``indexes``.</shortdoc>
</kw>
<kw name="Select From List By Label" source="./SeleniumLibrary/keywords/selectelement.py" lineno="256">
<arguments repr="locator: WebElement | str, *labels: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*labels: str">
<name>labels</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Selects options from selection list ``locator`` by ``labels``.

If more than one option is given for a single-selection list,
the last value will be selected. With multi-selection lists all
specified options are selected, but possible old selections are
not cleared.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Selects options from selection list ``locator`` by ``labels``.</shortdoc>
</kw>
<kw name="Select From List By Value" source="./SeleniumLibrary/keywords/selectelement.py" lineno="234">
<arguments repr="locator: WebElement | str, *values: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*values: str">
<name>values</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Selects options from selection list ``locator`` by ``values``.

If more than one option is given for a single-selection list,
the last value will be selected. With multi-selection lists all
specified options are selected, but possible old selections are
not cleared.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Selects options from selection list ``locator`` by ``values``.</shortdoc>
</kw>
<kw name="Select Radio Button" source="./SeleniumLibrary/keywords/formelement.py" lineno="198">
<arguments repr="group_name: str, value: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="group_name: str">
<name>group_name</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: str">
<name>value</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Sets the radio button group ``group_name`` to ``value``.

The radio button to be selected is located by two arguments:
- ``group_name`` is the name of the radio button group.
- ``value`` is the ``id`` or ``value`` attribute of the actual
  radio button.

Examples:
| `Select Radio Button` | size    | XL    |
| `Select Radio Button` | contact | email |</doc>
<shortdoc>Sets the radio button group ``group_name`` to ``value``.</shortdoc>
</kw>
<kw name="Set Browser Implicit Wait" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="698">
<arguments repr="value: timedelta">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: timedelta">
<name>value</name>
<type typedoc="timedelta">timedelta</type>
</arg>
</arguments>
<doc>Sets the implicit wait value used by Selenium.

Same as `Set Selenium Implicit Wait` but only affects the current
browser.</doc>
<shortdoc>Sets the implicit wait value used by Selenium.</shortdoc>
</kw>
<kw name="Set Default Url Scheme" source="./RPA/Browser/Selenium.py" lineno="79">
<arguments repr="scheme: str | None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="scheme: str | None">
<name>scheme</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
</arg>
</arguments>
<doc>Sets the default `scheme` used for URLs without a defined
value, such as `http` or `https`.

The feature is disabled if the value is set to `None`.</doc>
<shortdoc>Sets the default `scheme` used for URLs without a defined value, such as `http` or `https`.</shortdoc>
</kw>
<kw name="Set Download Directory" source="./RPA/Browser/Selenium.py" lineno="2090">
<arguments repr="directory: str | None = None, download_pdf: bool = True">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="directory: str | None = None">
<name>directory</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="download_pdf: bool = True">
<name>download_pdf</name>
<type typedoc="boolean">bool</type>
<default>True</default>
</arg>
</arguments>
<doc>Set browser download directory.

Works with ``Open Available Browser``, ``Open Chrome Browser`` and
``Open Headless Chrome Browser`` keywords (mainly with Chromium-based
browsers).

If the downloading doesn't work (file is not found on disk), try using the
browser in non-headless (headful) mode when opening it. (`headless=${False}`)

:param directory: Target directory for downloads, defaults to `None`, which
    means that this setting is removed.
:param download_pdf: A PDF file pointed by the URL is downloaded instead of
    being shown within browser's internal viewer when this is set to `True`.
    (enabled by default)

**Example: Robot Framework**

.. code-block:: robotframework

    *** Settings ***
    Library     RPA.Browser.Selenium
    Library     RPA.FileSystem

    *** Tasks ***
    Download PDF in custom directory
        Set Download Directory    ${OUTPUT_DIR}
        ${file_name} =   Set Variable    Robocorp-EULA-v1.0.pdf
        Open Available Browser    https://cdn.robocorp.com/legal/${file_name}
        ...    headless=${False}  # to enable PDF downloading
        @{files} =    List Files In Directory    ${OUTPUT_DIR}
        Log List    ${files}

**Example: Python**

.. code-block:: python

    from RPA.Browser.Selenium import Selenium
    from RPA.FileSystem import FileSystem

    selenium = Selenium()
    file_system = FileSystem()

    OUTPUT_DIR = "output"

    def download_pdf_in_custom_directory():
        selenium.set_download_directory(OUTPUT_DIR)
        file_name = "Robocorp-EULA-v1.0.pdf"
        selenium.open_available_browser(
            f"https://cdn.robocorp.com/legal/{file_name}", headless=False
        )
        files = file_system.list_files_in_directory(OUTPUT_DIR)
        for file_path in files:
            print(file_path)</doc>
<shortdoc>Set browser download directory.</shortdoc>
</kw>
<kw name="Set Focus To Element" source="./SeleniumLibrary/keywords/element.py" lineno="727">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Sets the focus to the element identified by ``locator``.

See the `Locating elements` section for details about the locator
syntax.

Prior to SeleniumLibrary 3.0 this keyword was named `Focus`.</doc>
<shortdoc>Sets the focus to the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Set Screenshot Directory" source="./SeleniumLibrary/keywords/screenshot.py" lineno="32">
<arguments repr="path: None | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="path: None | str">
<name>path</name>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Sets the directory for captured screenshots.

``path`` argument specifies the absolute path to a directory where
the screenshots should be written to. If the directory does not
exist, it will be created. The directory can also be set when
`importing` the library. If it is not configured anywhere,
screenshots are saved to the same directory where Robot Framework's
log file is written.

If ``path`` equals to EMBED (case insensitive) and
`Capture Page Screenshot` or `capture Element Screenshot` keywords
filename argument is not changed from the default value, then
the page or element screenshot is embedded as Base64 image to
the log.html.

The previous value is returned and can be used to restore
the original value later if needed.

Returning the previous value is new in SeleniumLibrary 3.0.
The persist argument was removed in SeleniumLibrary 3.2 and
EMBED is new in SeleniumLibrary 4.2.</doc>
<shortdoc>Sets the directory for captured screenshots.</shortdoc>
</kw>
<kw name="Set Selenium Implicit Wait" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="672">
<arguments repr="value: timedelta">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: timedelta">
<name>value</name>
<type typedoc="timedelta">timedelta</type>
</arg>
</arguments>
<doc>Sets the implicit wait value used by Selenium.

The value can be given as a number that is considered to be
seconds or as a human-readable string like ``1 second``.
The previous value is returned and can be used to restore
the original value later if needed.

This keyword sets the implicit wait for all opened browsers.
Use `Set Browser Implicit Wait` to set it only to the current
browser.

See the `Implicit wait` section above for more information.

Example:
| ${orig wait} = | `Set Selenium Implicit Wait` | 10 seconds |
| `Perform AJAX call that is slow` |
| `Set Selenium Implicit Wait` | ${orig wait} |</doc>
<shortdoc>Sets the implicit wait value used by Selenium.</shortdoc>
</kw>
<kw name="Set Selenium Speed" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="630">
<arguments repr="value: timedelta">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: timedelta">
<name>value</name>
<type typedoc="timedelta">timedelta</type>
</arg>
</arguments>
<doc>Sets the delay that is waited after each Selenium command.

The value can be given as a number that is considered to be
seconds or as a human-readable string like ``1 second``.
The previous value is returned and can be used to restore
the original value later if needed.

See the `Selenium Speed` section above for more information.

Example:
| `Set Selenium Speed` | 0.5 seconds |</doc>
<shortdoc>Sets the delay that is waited after each Selenium command.</shortdoc>
</kw>
<kw name="Set Selenium Timeout" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="650">
<arguments repr="value: timedelta">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="value: timedelta">
<name>value</name>
<type typedoc="timedelta">timedelta</type>
</arg>
</arguments>
<doc>Sets the timeout that is used by various keywords.

The value can be given as a number that is considered to be
seconds or as a human-readable string like ``1 second``.
The previous value is returned and can be used to restore
the original value later if needed.

See the `Timeout` section above for more information.

Example:
| ${orig timeout} = | `Set Selenium Timeout` | 15 seconds |
| `Open page that loads slowly` |
| `Set Selenium Timeout` | ${orig timeout} |</doc>
<shortdoc>Sets the timeout that is used by various keywords.</shortdoc>
</kw>
<kw name="Set Window Position" source="./SeleniumLibrary/keywords/window.py" lineno="269">
<arguments repr="x: int, y: int">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="x: int">
<name>x</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="y: int">
<name>y</name>
<type typedoc="integer">int</type>
</arg>
</arguments>
<doc>Sets window position using ``x`` and ``y`` coordinates.

The position is relative to the top left corner of the screen,
but some browsers exclude possible task bar set by the operating
system from the calculation. The actual position may thus be
different with different browsers.

Values can be given using strings containing numbers or by using
actual numbers. See also `Get Window Position`.

Example:
| `Set Window Position` | 100 | 200 |</doc>
<shortdoc>Sets window position using ``x`` and ``y`` coordinates.</shortdoc>
</kw>
<kw name="Set Window Size" source="./SeleniumLibrary/keywords/window.py" lineno="212">
<arguments repr="width: int, height: int, inner: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="width: int">
<name>width</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="height: int">
<name>height</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="inner: bool = False">
<name>inner</name>
<type typedoc="boolean">bool</type>
<default>False</default>
</arg>
</arguments>
<doc>Sets current windows size to given ``width`` and ``height``.

Values can be given using strings containing numbers or by using
actual numbers. See also `Get Window Size`.

Browsers have a limit on their minimum size. Trying to set them
smaller will cause the actual size to be bigger than the requested
size.

If ``inner`` parameter is set to True, keyword sets the necessary
window width and height to have the desired HTML DOM _window.innerWidth_
and _window.innerHeight_. See `Boolean arguments` for more details on how to set boolean
arguments.

The ``inner`` argument is new since SeleniumLibrary 4.0.

This ``inner`` argument does not support Frames. If a frame is selected,
switch to default before running this.

Example:
| `Set Window Size` | 800 | 600 |      |
| `Set Window Size` | 800 | 600 | True |</doc>
<shortdoc>Sets current windows size to given ``width`` and ``height``.</shortdoc>
</kw>
<kw name="Simulate Event" source="./SeleniumLibrary/keywords/element.py" lineno="871">
<arguments repr="locator: WebElement | str, event: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="event: str">
<name>event</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Simulates ``event`` on the element identified by ``locator``.

This keyword is useful if element has ``OnEvent`` handler that
needs to be explicitly invoked.

See the `Locating elements` section for details about the locator
syntax.

Prior to SeleniumLibrary 3.0 this keyword was named `Simulate`.</doc>
<shortdoc>Simulates ``event`` on the element identified by ``locator``.</shortdoc>
</kw>
<kw name="Submit Form" source="./SeleniumLibrary/keywords/formelement.py" lineno="29">
<arguments repr="locator: WebElement | None | str = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="locator: WebElement | None | str = None">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
<default>None</default>
</arg>
</arguments>
<doc>Submits a form identified by ``locator``.

If ``locator`` is not given, first form on the page is submitted.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Submits a form identified by ``locator``.</shortdoc>
</kw>
<kw name="Switch Browser" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="405">
<arguments repr="index_or_alias: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="index_or_alias: str">
<name>index_or_alias</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Switches between active browsers using ``index_or_alias``.

Indices are returned by the `Open Browser` keyword and aliases can
be given to it explicitly. Indices start from 1.

Example:
| `Open Browser`        | http://google.com | ff       |
| `Location Should Be`  | http://google.com |          |
| `Open Browser`        | http://yahoo.com  | ie       | alias=second |
| `Location Should Be`  | http://yahoo.com  |          |
| `Switch Browser`      | 1                 | # index  |
| `Page Should Contain` | I'm feeling lucky |          |
| `Switch Browser`      | second            | # alias  |
| `Page Should Contain` | More Yahoo!       |          |
| `Close All Browsers`  |                   |          |

Above example expects that there was no other open browsers when
opening the first one because it used index ``1`` when switching to
it later. If you are not sure about that, you can store the index
into a variable as below.

| ${index} =         | `Open Browser` | http://google.com |
| # Do something ... |                |                   |
| `Switch Browser`   | ${index}       |                   |</doc>
<shortdoc>Switches between active browsers using ``index_or_alias``.</shortdoc>
</kw>
<kw name="Switch Window" source="./SeleniumLibrary/keywords/window.py" lineno="33">
<arguments repr="locator: list | str = MAIN, timeout: str | None = None, browser: str = CURRENT">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="locator: list | str = MAIN">
<name>locator</name>
<type typedoc="list">list</type>
<type typedoc="string">str</type>
<default>MAIN</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: str | None = None">
<name>timeout</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="browser: str = CURRENT">
<name>browser</name>
<type typedoc="string">str</type>
<default>CURRENT</default>
</arg>
</arguments>
<doc>Switches to browser window matching ``locator``.

If the window is found, all subsequent commands use the selected
window, until this keyword is used again. If the window is not
found, this keyword fails. The previous windows handle is returned
and can be used to switch back to it later.

Notice that alerts should be handled with
`Handle Alert` or other alert related keywords.

The ``locator`` can be specified using different strategies somewhat
similarly as when `locating elements` on pages.

- By default, the ``locator`` is matched against window handle, name,
  title, and URL. Matching is done in that order and the first
  matching window is selected.

- The ``locator`` can specify an explicit strategy by using the format
  ``strategy:value`` (recommended) or ``strategy=value``. Supported
  strategies are ``name``, ``title``, and ``url``. These matches windows
  using their name, title, or URL, respectively. Additionally, ``default``
  can be used to explicitly use the default strategy explained above.

- If the ``locator`` is ``NEW`` (case-insensitive), the latest
  opened window is selected. It is an error if this is the same
  as the current window.

- If the ``locator`` is ``MAIN`` (default, case-insensitive),
  the main window is selected.

- If the ``locator`` is ``CURRENT`` (case-insensitive), nothing is
  done. This effectively just returns the current window handle.

- If the ``locator`` is not a string, it is expected to be a list
  of window handles _to exclude_. Such a list of excluded windows
  can be got from `Get Window Handles` before doing an action that
  opens a new window.

The ``timeout`` is used to specify how long keyword will poll to select
the new window. The ``timeout`` is new in SeleniumLibrary 3.2.

Example:
| `Click Link`      | popup1      |      | # Open new window |
| `Switch Window`   | example     |      | # Select window using default strategy |
| `Title Should Be` | Pop-up 1    |      |
| `Click Button`    | popup2      |      | # Open another window |
| ${handle} = | `Switch Window`   | NEW  | # Select latest opened window |
| `Title Should Be` | Pop-up 2    |      |
| `Switch Window`   | ${handle}   |      | # Select window using handle |
| `Title Should Be` | Pop-up 1    |      |
| `Switch Window`   | MAIN        |      | # Select the main window |
| `Title Should Be` | Main        |      |
| ${excludes} = | `Get Window Handles` | | # Get list of current windows |
| `Click Link`      | popup3      |      | # Open one more window |
| `Switch Window`   | ${excludes} |      | # Select window using excludes |
| `Title Should Be` | Pop-up 3    |      |

The ``browser`` argument allows with ``index_or_alias`` to implicitly switch to
a specific browser when switching to a window. See `Switch Browser`

- If the ``browser`` is ``CURRENT`` (case-insensitive), no other browser is
  selected.

*NOTE:*

- The ``strategy:value`` syntax is only supported by SeleniumLibrary
  3.0 and newer.
- Prior to SeleniumLibrary 3.0 matching windows by name, title
  and URL was case-insensitive.
- Earlier versions supported aliases ``None``, ``null`` and the
  empty string for selecting the main window, and alias ``self``
  for selecting the current window. Support for these aliases was
  removed in SeleniumLibrary 3.2.</doc>
<shortdoc>Switches to browser window matching ``locator``.</shortdoc>
</kw>
<kw name="Table Cell Should Contain" source="./SeleniumLibrary/keywords/tableelement.py" lineno="90">
<arguments repr="locator: WebElement | None | str, row: int, column: int, expected: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="row: int">
<name>row</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="column: int">
<name>column</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies table cell contains text ``expected``.

See `Get Table Cell` that this keyword uses internally for
an explanation about accepted arguments.</doc>
<shortdoc>Verifies table cell contains text ``expected``.</shortdoc>
</kw>
<kw name="Table Column Should Contain" source="./SeleniumLibrary/keywords/tableelement.py" lineno="113">
<arguments repr="locator: WebElement | None | str, column: int, expected: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="column: int">
<name>column</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies table column contains text ``expected``.

The table is located using the ``locator`` argument and its column
found using ``column``. See the `Locating elements` section for
details about the locator syntax.

Column indexes start from 1. It is possible to refer to columns
from the end by using negative indexes so that -1 is the last column,
-2 is the second last, and so on.

If a table contains cells that span multiple columns, those merged
cells count as a single column.

See `Page Should Contain Element` for an explanation about the
``loglevel`` argument.</doc>
<shortdoc>Verifies table column contains text ``expected``.</shortdoc>
</kw>
<kw name="Table Footer Should Contain" source="./SeleniumLibrary/keywords/tableelement.py" lineno="144">
<arguments repr="locator: WebElement | None | str, expected: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies table footer contains text ``expected``.

Any ``&lt;td&gt;`` element inside ``&lt;tfoot&gt;`` element is considered to
be part of the footer.

The table is located using the ``locator`` argument. See the
`Locating elements` section for details about the locator syntax.

See `Page Should Contain Element` for an explanation about the
``loglevel`` argument.</doc>
<shortdoc>Verifies table footer contains text ``expected``.</shortdoc>
</kw>
<kw name="Table Header Should Contain" source="./SeleniumLibrary/keywords/tableelement.py" lineno="169">
<arguments repr="locator: WebElement | None | str, expected: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies table header contains text ``expected``.

Any ``&lt;th&gt;`` element anywhere in the table is considered to be
part of the header.

The table is located using the ``locator`` argument. See the
`Locating elements` section for details about the locator syntax.

See `Page Should Contain Element` for an explanation about the
``loglevel`` argument.</doc>
<shortdoc>Verifies table header contains text ``expected``.</shortdoc>
</kw>
<kw name="Table Row Should Contain" source="./SeleniumLibrary/keywords/tableelement.py" lineno="194">
<arguments repr="locator: WebElement | None | str, row: int, expected: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="row: int">
<name>row</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies that table row contains text ``expected``.

The table is located using the ``locator`` argument and its column
found using ``column``. See the `Locating elements` section for
details about the locator syntax.

Row indexes start from 1. It is possible to refer to rows
from the end by using negative indexes so that -1 is the last row,
-2 is the second last, and so on.

If a table contains cells that span multiple rows, a match
only occurs for the uppermost row of those merged cells.

See `Page Should Contain Element` for an explanation about the
``loglevel`` argument.</doc>
<shortdoc>Verifies that table row contains text ``expected``.</shortdoc>
</kw>
<kw name="Table Should Contain" source="./SeleniumLibrary/keywords/tableelement.py" lineno="225">
<arguments repr="locator: WebElement | None | str, expected: str, loglevel: str = TRACE">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="loglevel: str = TRACE">
<name>loglevel</name>
<type typedoc="string">str</type>
<default>TRACE</default>
</arg>
</arguments>
<doc>Verifies table contains text ``expected``.

The table is located using the ``locator`` argument. See the
`Locating elements` section for details about the locator syntax.

See `Page Should Contain Element` for an explanation about the
``loglevel`` argument.</doc>
<shortdoc>Verifies table contains text ``expected``.</shortdoc>
</kw>
<kw name="Textarea Should Contain" source="./SeleniumLibrary/keywords/formelement.py" lineno="382">
<arguments repr="locator: WebElement | str, expected: str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies text area ``locator`` contains text ``expected``.

``message`` can be used to override default error message.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies text area ``locator`` contains text ``expected``.</shortdoc>
</kw>
<kw name="Textarea Value Should Be" source="./SeleniumLibrary/keywords/formelement.py" lineno="406">
<arguments repr="locator: WebElement | str, expected: str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies text area ``locator`` has exactly text ``expected``.

``message`` can be used to override default error message.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies text area ``locator`` has exactly text ``expected``.</shortdoc>
</kw>
<kw name="Textfield Should Contain" source="./SeleniumLibrary/keywords/formelement.py" lineno="334">
<arguments repr="locator: WebElement | str, expected: str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies text field ``locator`` contains text ``expected``.

``message`` can be used to override the default error message.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies text field ``locator`` contains text ``expected``.</shortdoc>
</kw>
<kw name="Textfield Value Should Be" source="./SeleniumLibrary/keywords/formelement.py" lineno="358">
<arguments repr="locator: WebElement | str, expected: str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies text field ``locator`` has exactly text ``expected``.

``message`` can be used to override default error message.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Verifies text field ``locator`` has exactly text ``expected``.</shortdoc>
</kw>
<kw name="Title Should Be" source="./SeleniumLibrary/keywords/browsermanagement.py" lineno="568">
<arguments repr="title: str, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="title: str">
<name>title</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Verifies that the current page title equals ``title``.

The ``message`` argument can be used to override the default error
message.

``message`` argument is new in SeleniumLibrary 3.1.</doc>
<shortdoc>Verifies that the current page title equals ``title``.</shortdoc>
</kw>
<kw name="Unselect All From List" source="./SeleniumLibrary/keywords/selectelement.py" lineno="278">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Unselects all options from multi-selection list ``locator``.

See the `Locating elements` section for details about the locator
syntax.

New in SeleniumLibrary 3.0.</doc>
<shortdoc>Unselects all options from multi-selection list ``locator``.</shortdoc>
</kw>
<kw name="Unselect Checkbox" source="./SeleniumLibrary/keywords/formelement.py" lineno="118">
<arguments repr="locator: WebElement | str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Removes the selection of checkbox identified by ``locator``.

Does nothing if the checkbox is not selected.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Removes the selection of checkbox identified by ``locator``.</shortdoc>
</kw>
<kw name="Unselect Frame" source="./SeleniumLibrary/keywords/frames.py" lineno="45">
<arguments repr="">
</arguments>
<doc>Sets the main frame as the current frame.

In practice cancels the previous `Select Frame` call.</doc>
<shortdoc>Sets the main frame as the current frame.</shortdoc>
</kw>
<kw name="Unselect From List By Index" source="./SeleniumLibrary/keywords/selectelement.py" lineno="295">
<arguments repr="locator: WebElement | str, *indexes: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*indexes: str">
<name>indexes</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Unselects options from selection list ``locator`` by ``indexes``.

Indexes of list options start from 0. This keyword works only with
multi-selection lists.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Unselects options from selection list ``locator`` by ``indexes``.</shortdoc>
</kw>
<kw name="Unselect From List By Label" source="./SeleniumLibrary/keywords/selectelement.py" lineno="347">
<arguments repr="locator: WebElement | str, *labels: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*labels: str">
<name>labels</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Unselects options from selection list ``locator`` by ``labels``.

This keyword works only with multi-selection lists.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Unselects options from selection list ``locator`` by ``labels``.</shortdoc>
</kw>
<kw name="Unselect From List By Value" source="./SeleniumLibrary/keywords/selectelement.py" lineno="322">
<arguments repr="locator: WebElement | str, *values: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_POSITIONAL" required="false" repr="*values: str">
<name>values</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Unselects options from selection list ``locator`` by ``values``.

This keyword works only with multi-selection lists.

See the `Locating elements` section for details about the locator
syntax.</doc>
<shortdoc>Unselects options from selection list ``locator`` by ``values``.</shortdoc>
</kw>
<kw name="Wait And Click Button" source="./RPA/Browser/Selenium.py" lineno="1317">
<arguments repr="locator: str, modifier: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: str">
<name>locator</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="modifier: str | None = None">
<name>modifier</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Click button identified by ``locator``, once it becomes visible.

``locator`` element locator

``modifier`` press given keys while clicking the element, e.g. CTRL

Example:

| Click Button When Visible  | //button[@class="mybutton"] |</doc>
<shortdoc>Click button identified by ``locator``, once it becomes visible.</shortdoc>
</kw>
<kw name="Wait For Condition" source="./SeleniumLibrary/keywords/waiting.py" lineno="31">
<arguments repr="condition: str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="condition: str">
<name>condition</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until ``condition`` is true or ``timeout`` expires.

The condition can be arbitrary JavaScript expression but it
must return a value to be evaluated. See `Execute JavaScript` for
information about accessing content on pages.

Fails if the timeout expires before the condition becomes true. See
the `Timeouts` section for more information about using timeouts
and their default value.

``error`` can be used to override the default error message.

Examples:
| `Wait For Condition` | return document.title == "New Title" |
| `Wait For Condition` | return jQuery.active == 0            |
| `Wait For Condition` | style = document.querySelector('h1').style; return style.background == "red" &amp;&amp; style.color == "white" |</doc>
<shortdoc>Waits until ``condition`` is true or ``timeout`` expires.</shortdoc>
</kw>
<kw name="Wait Until Element Contains" source="./SeleniumLibrary/keywords/waiting.py" lineno="373">
<arguments repr="locator: WebElement | None | str, text: str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the element ``locator`` contains ``text``.

Fails if ``timeout`` expires before the text appears. See
the `Timeouts` section for more information about using timeouts and
their default value and the `Locating elements` section for details
about the locator syntax.

``error`` can be used to override the default error message.</doc>
<shortdoc>Waits until the element ``locator`` contains ``text``.</shortdoc>
</kw>
<kw name="Wait Until Element Does Not Contain" source="./SeleniumLibrary/keywords/waiting.py" lineno="397">
<arguments repr="locator: WebElement | None | str, text: str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the element ``locator`` does not contain ``text``.

Fails if ``timeout`` expires before the text disappears. See
the `Timeouts` section for more information about using timeouts and
their default value and the `Locating elements` section for details
about the locator syntax.

``error`` can be used to override the default error message.</doc>
<shortdoc>Waits until the element ``locator`` does not contain ``text``.</shortdoc>
</kw>
<kw name="Wait Until Element Is Enabled" source="./SeleniumLibrary/keywords/waiting.py" lineno="345">
<arguments repr="locator: WebElement | None | str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the element ``locator`` is enabled.

Element is considered enabled if it is not disabled nor read-only.

Fails if ``timeout`` expires before the element is enabled. See
the `Timeouts` section for more information about using timeouts and
their default value and the `Locating elements` section for details
about the locator syntax.

``error`` can be used to override the default error message.

Considering read-only elements to be disabled is a new feature
in SeleniumLibrary 3.0.</doc>
<shortdoc>Waits until the element ``locator`` is enabled.</shortdoc>
</kw>
<kw name="Wait Until Element Is Not Visible" source="./SeleniumLibrary/keywords/waiting.py" lineno="322">
<arguments repr="locator: WebElement | None | str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the element ``locator`` is not visible.

Fails if ``timeout`` expires before the element is not visible. See
the `Timeouts` section for more information about using timeouts and
their default value and the `Locating elements` section for details
about the locator syntax.

``error`` can be used to override the default error message.</doc>
<shortdoc>Waits until the element ``locator`` is not visible.</shortdoc>
</kw>
<kw name="Wait Until Element Is Visible" source="./SeleniumLibrary/keywords/waiting.py" lineno="299">
<arguments repr="locator: WebElement | None | str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the element ``locator`` is visible.

Fails if ``timeout`` expires before the element is visible. See
the `Timeouts` section for more information about using timeouts and
their default value and the `Locating elements` section for details
about the locator syntax.

``error`` can be used to override the default error message.</doc>
<shortdoc>Waits until the element ``locator`` is visible.</shortdoc>
</kw>
<kw name="Wait Until Location Contains" source="./SeleniumLibrary/keywords/waiting.py" lineno="123">
<arguments repr="expected: str, timeout: timedelta | None = None, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the current URL contains ``expected``.

The ``expected`` argument contains the expected value in url.

Fails if ``timeout`` expires before the location contains. See
the `Timeouts` section for more information about using timeouts
and their default value.

The ``message`` argument can be used to override the default error
message.

New in SeleniumLibrary 4.0</doc>
<shortdoc>Waits until the current URL contains ``expected``.</shortdoc>
</kw>
<kw name="Wait Until Location Does Not Contain" source="./SeleniumLibrary/keywords/waiting.py" lineno="151">
<arguments repr="location: str, timeout: timedelta | None = None, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="location: str">
<name>location</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the current URL does not contains ``location``.

The ``location`` argument contains value not expected in url.

Fails if ``timeout`` expires before the location not contains. See
the `Timeouts` section for more information about using timeouts
and their default value.

The ``message`` argument can be used to override the default error
message.

New in SeleniumLibrary 4.3</doc>
<shortdoc>Waits until the current URL does not contains ``location``.</shortdoc>
</kw>
<kw name="Wait Until Location Is" source="./SeleniumLibrary/keywords/waiting.py" lineno="66">
<arguments repr="expected: str, timeout: timedelta | None = None, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="expected: str">
<name>expected</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the current URL is ``expected``.

The ``expected`` argument is the expected value in url.

Fails if ``timeout`` expires before the location is. See
the `Timeouts` section for more information about using timeouts
and their default value.

The ``message`` argument can be used to override the default error
message.

New in SeleniumLibrary 4.0</doc>
<shortdoc>Waits until the current URL is ``expected``.</shortdoc>
</kw>
<kw name="Wait Until Location Is Not" source="./SeleniumLibrary/keywords/waiting.py" lineno="95">
<arguments repr="location: str, timeout: timedelta | None = None, message: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="location: str">
<name>location</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the current URL is not ``location``.

The ``location`` argument is the unexpected value in url.

Fails if ``timeout`` expires before the location is not. See
the `Timeouts` section for more information about using timeouts
and their default value.

The ``message`` argument can be used to override the default error
message.

New in SeleniumLibrary 4.3</doc>
<shortdoc>Waits until the current URL is not ``location``.</shortdoc>
</kw>
<kw name="Wait Until Page Contains" source="./SeleniumLibrary/keywords/waiting.py" lineno="179">
<arguments repr="text: str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until ``text`` appears on the current page.

Fails if ``timeout`` expires before the text appears. See
the `Timeouts` section for more information about using timeouts
and their default value.

``error`` can be used to override the default error message.</doc>
<shortdoc>Waits until ``text`` appears on the current page.</shortdoc>
</kw>
<kw name="Wait Until Page Contains Element" source="./SeleniumLibrary/keywords/waiting.py" lineno="223">
<arguments repr="locator: WebElement | None | str, timeout: timedelta | None = None, error: str | None = None, limit: int | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="limit: int | None = None">
<name>limit</name>
<type typedoc="integer">int</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the element ``locator`` appears on the current page.

Fails if ``timeout`` expires before the element appears. See
the `Timeouts` section for more information about using timeouts and
their default value and the `Locating elements` section for details
about the locator syntax.

``error`` can be used to override the default error message.

The ``limit`` argument can used to define how many elements the
page should contain. When ``limit`` is `None` (default) page can
contain one or more elements. When limit is a number, page must
contain same number of elements.

``limit`` is new in SeleniumLibrary 4.4</doc>
<shortdoc>Waits until the element ``locator`` appears on the current page.</shortdoc>
</kw>
<kw name="Wait Until Page Does Not Contain" source="./SeleniumLibrary/keywords/waiting.py" lineno="201">
<arguments repr="text: str, timeout: timedelta | None = None, error: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="text: str">
<name>text</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until ``text`` disappears from the current page.

Fails if ``timeout`` expires before the text disappears. See
the `Timeouts` section for more information about using timeouts
and their default value.

``error`` can be used to override the default error message.</doc>
<shortdoc>Waits until ``text`` disappears from the current page.</shortdoc>
</kw>
<kw name="Wait Until Page Does Not Contain Element" source="./SeleniumLibrary/keywords/waiting.py" lineno="261">
<arguments repr="locator: WebElement | None | str, timeout: timedelta | None = None, error: str | None = None, limit: int | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="locator: WebElement | None | str">
<name>locator</name>
<type>WebElement</type>
<type typedoc="None">None</type>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: timedelta | None = None">
<name>timeout</name>
<type typedoc="timedelta">timedelta</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="error: str | None = None">
<name>error</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="limit: int | None = None">
<name>limit</name>
<type typedoc="integer">int</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Waits until the element ``locator`` disappears from the current page.

Fails if ``timeout`` expires before the element disappears. See
the `Timeouts` section for more information about using timeouts and
their default value and the `Locating elements` section for details
about the locator syntax.

``error`` can be used to override the default error message.

The ``limit`` argument can used to define how many elements the
page should not contain. When ``limit`` is `None` (default) page can`t
contain any elements. When limit is a number, page must not
contain same number of elements.

``limit`` is new in SeleniumLibrary 4.4</doc>
<shortdoc>Waits until the element ``locator`` disappears from the current page.</shortdoc>
</kw>
</keywords>
<datatypes>
</datatypes>
<typedocs>
<type name="boolean" type="Standard">
<doc>Strings ``TRUE``, ``YES``, ``ON`` and ``1`` are converted to Boolean ``True``,
the empty string as well as strings ``FALSE``, ``NO``, ``OFF`` and ``0``
are converted to Boolean ``False``, and the string ``NONE`` is converted
to the Python ``None`` object. Other strings and other accepted values are
passed as-is, allowing keywords to handle them specially if
needed. All string comparisons are case-insensitive.

Examples: ``TRUE`` (converted to ``True``), ``off`` (converted to ``False``),
``example`` (used as-is)
</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
<type>None</type>
</accepts>
<usages>
<usage>Add Cookie</usage>
<usage>Add Location Strategy</usage>
<usage>Click Button</usage>
<usage>Click Element</usage>
<usage>Click Element When Visible</usage>
<usage>Click Image</usage>
<usage>Click Link</usage>
<usage>Does Element Contain</usage>
<usage>Element Should Contain</usage>
<usage>Element Should Not Contain</usage>
<usage>Element Text Should Be</usage>
<usage>Element Text Should Not Be</usage>
<usage>Get Cookies</usage>
<usage>Get List Items</usage>
<usage>Get Window Size</usage>
<usage>Input Password</usage>
<usage>Input Text</usage>
<usage>Is Element Disabled</usage>
<usage>Is Element Enabled</usage>
<usage>Is Element Focused</usage>
<usage>Is Element Text</usage>
<usage>Is Element Visible</usage>
<usage>Open Available Browser</usage>
<usage>Open Browser</usage>
<usage>Open Chrome Browser</usage>
<usage>Set Download Directory</usage>
<usage>Set Window Size</usage>
</usages>
</type>
<type name="dictionary" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#dict|dictionary]
literals. They are converted to actual dictionaries using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
dictionaries and other containers.

Examples: ``{'a': 1, 'b': 2}``, ``{'key': 1, 'nested': {'key': 2}}``
</doc>
<accepts>
<type>string</type>
<type>Mapping</type>
</accepts>
<usages>
<usage>Open Available Browser</usage>
<usage>Open Browser</usage>
<usage>Open Chrome Browser</usage>
<usage>Print To Pdf</usage>
</usages>
</type>
<type name="float" type="Standard">
<doc>Conversion is done using Python's
[https://docs.python.org/library/functions.html#float|float] built-in function.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``3.14``, ``2.9979e8``, ``10 000.000 01``
</doc>
<accepts>
<type>string</type>
<type>Real</type>
</accepts>
<usages>
<usage>Does Alert Contain</usage>
<usage>Does Alert Not Contain</usage>
</usages>
</type>
<type name="integer" type="Standard">
<doc>Conversion is done using Python's [https://docs.python.org/library/functions.html#int|int]
built-in function. Floating point
numbers are accepted only if they can be represented as integers exactly.
For example, ``1.0`` is accepted and ``1.1`` is not.

Starting from RF 4.1, it is possible to use hexadecimal, octal and binary
numbers by prefixing values with ``0x``, ``0o`` and ``0b``, respectively.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``42``, ``-1``, ``0b1010``, ``10 000 000``, ``0xBAD_C0FFEE``
</doc>
<accepts>
<type>string</type>
<type>float</type>
</accepts>
<usages>
<usage>Attach Chrome Browser</usage>
<usage>Click Element At Coordinates</usage>
<usage>Does Page Contain Element</usage>
<usage>Does Table Cell Contain</usage>
<usage>Does Table Column Contain</usage>
<usage>Does Table Row Contain</usage>
<usage>Drag And Drop By Offset</usage>
<usage>Get Table Cell</usage>
<usage>Open Available Browser</usage>
<usage>Page Should Contain Element</usage>
<usage>Set Window Position</usage>
<usage>Set Window Size</usage>
<usage>Table Cell Should Contain</usage>
<usage>Table Column Should Contain</usage>
<usage>Table Row Should Contain</usage>
<usage>Wait Until Page Contains Element</usage>
<usage>Wait Until Page Does Not Contain Element</usage>
</usages>
</type>
<type name="list" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#list|list]
literals. They are converted to actual lists using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
lists and other containers.

Examples: ``['one', 'two']``, ``[('one', 1), ('two', 2)]``
</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>Switch Window</usage>
</usages>
</type>
<type name="None" type="Standard">
<doc>String ``NONE`` (case-insensitive) is converted to Python ``None`` object.
Other values cause an error.
</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>Add Cookie</usage>
<usage>Alert Should Be Present</usage>
<usage>Alert Should Not Be Present</usage>
<usage>Attach Chrome Browser</usage>
<usage>Capture Element Screenshot</usage>
<usage>Click Button When Visible</usage>
<usage>Click Element When Visible</usage>
<usage>Create Webdriver</usage>
<usage>Does Alert Contain</usage>
<usage>Does Alert Not Contain</usage>
<usage>Does Page Contain Element</usage>
<usage>Element Attribute Value Should Be</usage>
<usage>Element Should Be Visible</usage>
<usage>Element Should Contain</usage>
<usage>Element Should Not Be Visible</usage>
<usage>Element Should Not Contain</usage>
<usage>Element Text Should Be</usage>
<usage>Element Text Should Not Be</usage>
<usage>Get Table Cell</usage>
<usage>Handle Alert</usage>
<usage>Input Text Into Alert</usage>
<usage>Is Alert Present</usage>
<usage>Location Should Be</usage>
<usage>Location Should Contain</usage>
<usage>Open Available Browser</usage>
<usage>Open Browser</usage>
<usage>Open Chrome Browser</usage>
<usage>Page Should Contain Button</usage>
<usage>Page Should Contain Checkbox</usage>
<usage>Page Should Contain Element</usage>
<usage>Page Should Contain Image</usage>
<usage>Page Should Contain Link</usage>
<usage>Page Should Contain List</usage>
<usage>Page Should Contain Radio Button</usage>
<usage>Page Should Contain Textfield</usage>
<usage>Page Should Not Contain Button</usage>
<usage>Page Should Not Contain Checkbox</usage>
<usage>Page Should Not Contain Element</usage>
<usage>Page Should Not Contain Image</usage>
<usage>Page Should Not Contain Link</usage>
<usage>Page Should Not Contain List</usage>
<usage>Page Should Not Contain Radio Button</usage>
<usage>Page Should Not Contain Textfield</usage>
<usage>Press Keys</usage>
<usage>Print To Pdf</usage>
<usage>Register Keyword To Run On Failure</usage>
<usage>Screenshot</usage>
<usage>Set Default Url Scheme</usage>
<usage>Set Download Directory</usage>
<usage>Set Screenshot Directory</usage>
<usage>Submit Form</usage>
<usage>Switch Window</usage>
<usage>Table Cell Should Contain</usage>
<usage>Table Column Should Contain</usage>
<usage>Table Footer Should Contain</usage>
<usage>Table Header Should Contain</usage>
<usage>Table Row Should Contain</usage>
<usage>Table Should Contain</usage>
<usage>Textarea Should Contain</usage>
<usage>Textarea Value Should Be</usage>
<usage>Textfield Should Contain</usage>
<usage>Textfield Value Should Be</usage>
<usage>Title Should Be</usage>
<usage>Wait And Click Button</usage>
<usage>Wait For Condition</usage>
<usage>Wait Until Element Contains</usage>
<usage>Wait Until Element Does Not Contain</usage>
<usage>Wait Until Element Is Enabled</usage>
<usage>Wait Until Element Is Not Visible</usage>
<usage>Wait Until Element Is Visible</usage>
<usage>Wait Until Location Contains</usage>
<usage>Wait Until Location Does Not Contain</usage>
<usage>Wait Until Location Is</usage>
<usage>Wait Until Location Is Not</usage>
<usage>Wait Until Page Contains</usage>
<usage>Wait Until Page Contains Element</usage>
<usage>Wait Until Page Does Not Contain</usage>
<usage>Wait Until Page Does Not Contain Element</usage>
</usages>
</type>
<type name="string" type="Standard">
<doc>All arguments are converted to Unicode strings.</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>Add Cookie</usage>
<usage>Add Location Strategy</usage>
<usage>Alert Should Be Present</usage>
<usage>Alert Should Not Be Present</usage>
<usage>Assign Id To Element</usage>
<usage>Attach Chrome Browser</usage>
<usage>Capture Element Screenshot</usage>
<usage>Capture Page Screenshot</usage>
<usage>Checkbox Should Be Selected</usage>
<usage>Checkbox Should Not Be Selected</usage>
<usage>Choose File</usage>
<usage>Clear Element Text</usage>
<usage>Click Button</usage>
<usage>Click Button When Visible</usage>
<usage>Click Element</usage>
<usage>Click Element At Coordinates</usage>
<usage>Click Element If Visible</usage>
<usage>Click Element When Visible</usage>
<usage>Click Image</usage>
<usage>Click Link</usage>
<usage>Cover Element</usage>
<usage>Create Webdriver</usage>
<usage>Current Frame Should Contain</usage>
<usage>Current Frame Should Not Contain</usage>
<usage>Does Alert Contain</usage>
<usage>Does Alert Not Contain</usage>
<usage>Does Element Contain</usage>
<usage>Does Frame Contain</usage>
<usage>Does Location Contain</usage>
<usage>Does Page Contain</usage>
<usage>Does Page Contain Button</usage>
<usage>Does Page Contain Checkbox</usage>
<usage>Does Page Contain Element</usage>
<usage>Does Page Contain Image</usage>
<usage>Does Page Contain Link</usage>
<usage>Does Page Contain List</usage>
<usage>Does Page Contain Radio Button</usage>
<usage>Does Page Contain Textfield</usage>
<usage>Does Table Cell Contain</usage>
<usage>Does Table Column Contain</usage>
<usage>Does Table Contain</usage>
<usage>Does Table Footer Contain</usage>
<usage>Does Table Header Contain</usage>
<usage>Does Table Row Contain</usage>
<usage>Does Textarea Contain</usage>
<usage>Does Textfield Contain</usage>
<usage>Double Click Element</usage>
<usage>Drag And Drop</usage>
<usage>Drag And Drop By Offset</usage>
<usage>Element Attribute Value Should Be</usage>
<usage>Element Should Be Disabled</usage>
<usage>Element Should Be Enabled</usage>
<usage>Element Should Be Focused</usage>
<usage>Element Should Be Visible</usage>
<usage>Element Should Contain</usage>
<usage>Element Should Not Be Visible</usage>
<usage>Element Should Not Contain</usage>
<usage>Element Text Should Be</usage>
<usage>Element Text Should Not Be</usage>
<usage>Execute Async Javascript</usage>
<usage>Execute Javascript</usage>
<usage>Frame Should Contain</usage>
<usage>Get Cookie</usage>
<usage>Get Element Attribute</usage>
<usage>Get Element Count</usage>
<usage>Get Element Size</usage>
<usage>Get Element Status</usage>
<usage>Get Horizontal Position</usage>
<usage>Get List Items</usage>
<usage>Get Locations</usage>
<usage>Get Selected List Label</usage>
<usage>Get Selected List Labels</usage>
<usage>Get Selected List Value</usage>
<usage>Get Selected List Values</usage>
<usage>Get Table Cell</usage>
<usage>Get Text</usage>
<usage>Get Value</usage>
<usage>Get Vertical Position</usage>
<usage>Get WebElement</usage>
<usage>Get WebElements</usage>
<usage>Get Window Handles</usage>
<usage>Get Window Identifiers</usage>
<usage>Get Window Names</usage>
<usage>Get Window Titles</usage>
<usage>Go To</usage>
<usage>Handle Alert</usage>
<usage>Highlight Elements</usage>
<usage>Input Password</usage>
<usage>Input Text</usage>
<usage>Input Text Into Alert</usage>
<usage>Input Text When Element Is Visible</usage>
<usage>Is Alert Present</usage>
<usage>Is Checkbox Selected</usage>
<usage>Is Element Attribute Equal To</usage>
<usage>Is Element Disabled</usage>
<usage>Is Element Enabled</usage>
<usage>Is Element Focused</usage>
<usage>Is Element Text</usage>
<usage>Is Element Visible</usage>
<usage>Is List Selected</usage>
<usage>Is List Selection</usage>
<usage>Is Location</usage>
<usage>Is Radio Button Selected</usage>
<usage>Is Radio Button Set To</usage>
<usage>Is Textarea Value</usage>
<usage>Is Textfield Value</usage>
<usage>Is Title</usage>
<usage>List Selection Should Be</usage>
<usage>List Should Have No Selections</usage>
<usage>Location Should Be</usage>
<usage>Location Should Contain</usage>
<usage>Log Source</usage>
<usage>Mouse Down</usage>
<usage>Mouse Down On Image</usage>
<usage>Mouse Down On Link</usage>
<usage>Mouse Out</usage>
<usage>Mouse Over</usage>
<usage>Mouse Up</usage>
<usage>Open Available Browser</usage>
<usage>Open Browser</usage>
<usage>Open Chrome Browser</usage>
<usage>Open Context Menu</usage>
<usage>Open Headless Chrome Browser</usage>
<usage>Open User Browser</usage>
<usage>Page Should Contain</usage>
<usage>Page Should Contain Button</usage>
<usage>Page Should Contain Checkbox</usage>
<usage>Page Should Contain Element</usage>
<usage>Page Should Contain Image</usage>
<usage>Page Should Contain Link</usage>
<usage>Page Should Contain List</usage>
<usage>Page Should Contain Radio Button</usage>
<usage>Page Should Contain Textfield</usage>
<usage>Page Should Not Contain</usage>
<usage>Page Should Not Contain Button</usage>
<usage>Page Should Not Contain Checkbox</usage>
<usage>Page Should Not Contain Element</usage>
<usage>Page Should Not Contain Image</usage>
<usage>Page Should Not Contain Link</usage>
<usage>Page Should Not Contain List</usage>
<usage>Page Should Not Contain Radio Button</usage>
<usage>Page Should Not Contain Textfield</usage>
<usage>Press Key</usage>
<usage>Press Keys</usage>
<usage>Print To Pdf</usage>
<usage>Radio Button Should Be Set To</usage>
<usage>Radio Button Should Not Be Selected</usage>
<usage>Register Keyword To Run On Failure</usage>
<usage>Remove Location Strategy</usage>
<usage>Screenshot</usage>
<usage>Scroll Element Into View</usage>
<usage>Select All From List</usage>
<usage>Select Checkbox</usage>
<usage>Select Frame</usage>
<usage>Select From List By Index</usage>
<usage>Select From List By Label</usage>
<usage>Select From List By Value</usage>
<usage>Select Radio Button</usage>
<usage>Set Default Url Scheme</usage>
<usage>Set Download Directory</usage>
<usage>Set Focus To Element</usage>
<usage>Set Screenshot Directory</usage>
<usage>Simulate Event</usage>
<usage>Submit Form</usage>
<usage>Switch Browser</usage>
<usage>Switch Window</usage>
<usage>Table Cell Should Contain</usage>
<usage>Table Column Should Contain</usage>
<usage>Table Footer Should Contain</usage>
<usage>Table Header Should Contain</usage>
<usage>Table Row Should Contain</usage>
<usage>Table Should Contain</usage>
<usage>Textarea Should Contain</usage>
<usage>Textarea Value Should Be</usage>
<usage>Textfield Should Contain</usage>
<usage>Textfield Value Should Be</usage>
<usage>Title Should Be</usage>
<usage>Unselect All From List</usage>
<usage>Unselect Checkbox</usage>
<usage>Unselect From List By Index</usage>
<usage>Unselect From List By Label</usage>
<usage>Unselect From List By Value</usage>
<usage>Wait And Click Button</usage>
<usage>Wait For Condition</usage>
<usage>Wait Until Element Contains</usage>
<usage>Wait Until Element Does Not Contain</usage>
<usage>Wait Until Element Is Enabled</usage>
<usage>Wait Until Element Is Not Visible</usage>
<usage>Wait Until Element Is Visible</usage>
<usage>Wait Until Location Contains</usage>
<usage>Wait Until Location Does Not Contain</usage>
<usage>Wait Until Location Is</usage>
<usage>Wait Until Location Is Not</usage>
<usage>Wait Until Page Contains</usage>
<usage>Wait Until Page Contains Element</usage>
<usage>Wait Until Page Does Not Contain</usage>
<usage>Wait Until Page Does Not Contain Element</usage>
</usages>
</type>
<type name="timedelta" type="Standard">
<doc>Strings are expected to represent a time interval in one of
the time formats Robot Framework supports:
- a number representing seconds like ``42`` or ``10.5``
- a time string like ``1 hour 2 seconds`` or ``1h 2s``
- a "timer" string like ``01:02`` (1 minute 2 seconds) or ``01:00:03`` (1 hour 3 seconds)

Integers and floats are considered to be seconds.

See the [https://robotframework.org/robotframework/|Robot Framework User Guide]
for more details about the supported time formats.
</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
</accepts>
<usages>
<usage>Alert Should Be Present</usage>
<usage>Alert Should Not Be Present</usage>
<usage>Handle Alert</usage>
<usage>Input Text Into Alert</usage>
<usage>Set Browser Implicit Wait</usage>
<usage>Set Selenium Implicit Wait</usage>
<usage>Set Selenium Speed</usage>
<usage>Set Selenium Timeout</usage>
<usage>Wait For Condition</usage>
<usage>Wait Until Element Contains</usage>
<usage>Wait Until Element Does Not Contain</usage>
<usage>Wait Until Element Is Enabled</usage>
<usage>Wait Until Element Is Not Visible</usage>
<usage>Wait Until Element Is Visible</usage>
<usage>Wait Until Location Contains</usage>
<usage>Wait Until Location Does Not Contain</usage>
<usage>Wait Until Location Is</usage>
<usage>Wait Until Location Is Not</usage>
<usage>Wait Until Page Contains</usage>
<usage>Wait Until Page Contains Element</usage>
<usage>Wait Until Page Does Not Contain</usage>
<usage>Wait Until Page Does Not Contain Element</usage>
</usages>
</type>
</typedocs>
</keywordspec>
