<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="RPA.MFA" type="LIBRARY" format="REST" scope="GLOBAL" generated="2023-03-15T12:04:06Z" specversion="4" source="./RPA/MFA.py" lineno="49">
<version/>
<doc>**RPA.MFA** is a library intended mainly for generating one-time passwords (OTP)
and not only, as OAuth2 support was introduced lately.

Available with **rpaframework** version: 19.4.0

Based on the `pyotp &lt;https://pypi.org/project/pyotp/&gt;`_ and
`requests_oauthlib &lt;https://pypi.org/project/requests-oauthlib/&gt;`_ packages. It
provides support for both MFA with the ``* OTP`` related keywords and OAuth2
"Authorization Code Flow" with the ``* OAuth *`` related keywords.

In the below example the **mfa** secret we are reading from the Robocorp
Vault is the passcode generated by the Authenticator service. The passcode
value is stored into the Vault with key **otpsecret**.

Passcode is typically a long string (16-32 characters), which is provided
in a form of QR image, but it can be obtained by requesting access to a string.

Note that same code can be used to add a mobile phone as a duplicate authentication
device at the same time when the same code is added into the Vault.

**Robot framework example usage:**

.. code-block:: robotframework

    *** Settings ***
    Library     RPA.MFA
    Library     RPA.Robocorp.Vault

    *** Tasks ***
    Generate time based code
        ${secrets}=    Get Secret   mfa
        ${code}=    Get Time Based OTP    ${secrets}[otpsecret]


**Python example usage**

.. code-block:: python

    from RPA.MFA import MFA
    from RPA.Robocorp.Vault import Vault


    def main():
        secrets = Vault().get_secret("mfa")
        code = MFA().get_time_based_otp(secrets["otpsecret"])</doc>
<tags>
</tags>
<inits>
<init name="__init__" lineno="100">
<arguments repr="vault_name: str | None = None, vault_key: str | None = None, mode: OTPMode | None = TIME">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="vault_name: str | None = None">
<name>vault_name</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="vault_key: str | None = None">
<name>vault_key</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mode: OTPMode | None = TIME">
<name>mode</name>
<type typedoc="OTPMode">OTPMode</type>
<type typedoc="None">None</type>
<default>TIME</default>
</arg>
</arguments>
<doc>Initialize self.  See help(type(self)) for accurate signature.</doc>
<shortdoc>Initialize self.  See help(type(self)) for accurate signature.</shortdoc>
</init>
</inits>
<keywords>
<kw name="Generate Oauth Url" lineno="188">
<arguments repr="auth_url: str, *, client_id: str, redirect_uri: str, scope: str, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="auth_url: str">
<name>auth_url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="NAMED_ONLY_MARKER" required="false" repr="*">
</arg>
<arg kind="NAMED_ONLY" required="true" repr="client_id: str">
<name>client_id</name>
<type typedoc="string">str</type>
</arg>
<arg kind="NAMED_ONLY" required="true" repr="redirect_uri: str">
<name>redirect_uri</name>
<type typedoc="string">str</type>
</arg>
<arg kind="NAMED_ONLY" required="true" repr="scope: str">
<name>scope</name>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<doc>Generates an authorization URL which must be opened by the user to start the
OAuth2 flow and obtain an authorization code as response.

The received response URL should be passed further with ``Get OAuth Token`` in
order to complete the flow. Arbitrary keyword arguments can be passed to the
keyword, which will be redirected to the wrapped `oauthlib` library method
call.

:param auth_url: Authorization endpoint to call the request on. (https URL
    usually ending with '/authorize')
:param client_id: Client app ID. (generated by the provider)
:param redirect_uri: Redirect URL allowed by the Client app configuration. (
    necessary for getting the `code` response)
:param scope: Space-separated string of permissions. (accepted during the
    consent screen)
:returns: Authorization URL string not containing any sensitive info in it.
    (call it with `access_type="offline"` or set the right `scope` in the
    authorization URL for ensuring the existence of the refresh token)

**Example: Robot Framework**

.. code-block:: robotframework

    *** Tasks ***
    Start OAuth Flow
        ${auth_url} =    Generate OAuth URL
        ...     https://accounts.google.com/o/oauth2/auth
        ...     client_id=810482312368-19htmcgcj*******googleusercontent.com
        ...     redirect_uri=https://developers.google.com/oauthplayground
        ...     scope=https://mail.google.com
        ...     access_type=offline     prompt=consent  # explicit grant
        Log     Start OAuth2 flow: ${auth_url}

**Example: Python**

.. code-block:: python

    from RPA.MFA import MFA

    lib_mfa = MFA()
    auth_url = lib_mfa.generate_oauth_url(
        "https://accounts.google.com/o/oauth2/auth", ...
    )
    print(f"Start OAuth2 flow: {auth_url}")</doc>
<shortdoc>Generates an authorization URL which must be opened by the user to start the OAuth2 flow and obtain an authorization code as response.</shortdoc>
</kw>
<kw name="Get Counter Based Otp" lineno="161">
<arguments repr="counter: int, otp_passcode: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="counter: int">
<name>counter</name>
<type typedoc="integer">int</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="otp_passcode: str | None = None">
<name>otp_passcode</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Get `counter` based one time password using separately set
passcode or by parameter `otp_passcode`. The counter index is
given by the `counter` parameter.

:param counter: the index of the counter
:param otp_passcode: the passcode provided by the Authenticator</doc>
<shortdoc>Get `counter` based one time password using separately set passcode or by parameter `otp_passcode`. The counter index is given by the `counter` parameter.</shortdoc>
</kw>
<kw name="Get Oauth Token" lineno="242">
<arguments repr="token_url: str, *, client_secret: str, response_url: str, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="token_url: str">
<name>token_url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="NAMED_ONLY_MARKER" required="false" repr="*">
</arg>
<arg kind="NAMED_ONLY" required="true" repr="client_secret: str">
<name>client_secret</name>
<type typedoc="string">str</type>
</arg>
<arg kind="NAMED_ONLY" required="true" repr="response_url: str">
<name>response_url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<doc>Exchanges the code obtained previously with ``Generate OAuth URL`` for a
token.

The refresh token from the returned dictionary can be used further with the
``Refresh OAuth Token`` keyword in order to obtain a new access token when the
previous one expires. (usually after one hour)
Arbitrary keyword arguments can be passed to the keyword, which will be
redirected to the wrapped `oauthlib` library method call.

:param token_url: Token endpoint used with a POST request in order to retrieve
    the token data. (https URL usually ending with '/token')
:param client_secret: Client app secret. (generated by the provider)
:param response_url: The final URL containing the authorization `code` found in
    the address bar after authenticating and authorizing the Client app
    through the authorization URL.
:returns: A dictionary containing the access token, metadata and optionally the
    refresh token.

**Example: Robot Framework**

.. code-block:: robotframework

    *** Tasks ***
    Finish OAuth Flow
        ${token} =      Get OAuth Token
        ...     https://accounts.google.com/o/oauth2/token
        ...     client_secret=GOCSPX-******mqZAW89
        ...     response_url=${resp_url}  # redirect of `Generate OAuth URL`

**Example: Python**

.. code-block:: python

    from RPA.MFA import MFA

    lib_mfa = MFA()
    lib_mfa.get_oauth_token("https://accounts.google.com/o/oauth2/token", ...)</doc>
<shortdoc>Exchanges the code obtained previously with ``Generate OAuth URL`` for a token.</shortdoc>
</kw>
<kw name="Get Time Based Otp" lineno="148">
<arguments repr="otp_passcode: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="otp_passcode: str | None = None">
<name>otp_passcode</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
</arguments>
<doc>Get `time` based one time password using separately set
passcode or by parameter `otp_passcode`.

:param otp_passcode: the passcode provided by the Authenticator</doc>
<shortdoc>Get `time` based one time password using separately set passcode or by parameter `otp_passcode`.</shortdoc>
</kw>
<kw name="Refresh Oauth Token" lineno="292">
<arguments repr="token_url: str, *, client_id: str | None = None, client_secret: str, refresh_token: str | None = None, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="token_url: str">
<name>token_url</name>
<type typedoc="string">str</type>
</arg>
<arg kind="NAMED_ONLY_MARKER" required="false" repr="*">
</arg>
<arg kind="NAMED_ONLY" required="false" repr="client_id: str | None = None">
<name>client_id</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="NAMED_ONLY" required="true" repr="client_secret: str">
<name>client_secret</name>
<type typedoc="string">str</type>
</arg>
<arg kind="NAMED_ONLY" required="false" repr="refresh_token: str | None = None">
<name>refresh_token</name>
<type typedoc="string">str</type>
<type typedoc="None">None</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<doc>Refreshes the token as the access one usually expires after 1h and the
refresh one never expires. (as long as it doesn't get revoked)

The effect of this keyword is similar to ``Get OAuth Token``, but this time you
refresh unattended an already existing token by receiving a new one instead.
Arbitrary keyword arguments can be passed to the keyword, which will be
redirected to the wrapped `oauthlib` library method call.

:param token_url: Token endpoint used with a POST request in order to refresh
    the token data. (https URL usually ending with '/token')
:param client_id: Client app ID. (generated by the provider)
:param client_secret: Client app secret. (generated by the provider)
:param refresh_token: Refresh token string found in the dictionary obtained
    with ``Get OAuth Token`` or ``Refresh OAuth Token``.
:returns: A token dictionary containing a new access token and updated
    metadata. (the refresh token inside isn't guaranteed to remain constant)

**Example: Robot Framework**

.. code-block:: robotframework

    *** Tasks ***
    Refresh OAuth Flow
        ${token} =      Refresh OAuth Token
        ...     https://accounts.google.com/o/oauth2/token
        ...     client_id=810482312368-19htmcgcj*******googleusercontent.com
        ...     client_secret=GOCSPX-******mqZAW89
        ...     refresh_token=${token}[refresh_token]  # from `Get OAuth Token`

**Example: Python**

.. code-block:: python

    from RPA.MFA import MFA

    lib_mfa = MFA()
    lib_mfa.refresh_oauth_token(
        "https://accounts.google.com/o/oauth2/token", ...
    )</doc>
<shortdoc>Refreshes the token as the access one usually expires after 1h and the refresh one never expires. (as long as it doesn't get revoked)</shortdoc>
</kw>
<kw name="Set Counter Based Otp" lineno="140">
<arguments repr="otp_passcode: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="otp_passcode: str">
<name>otp_passcode</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Set `counter` based OTP with passcode.

:param otp_passcode: the passcode provided by the Authenticator</doc>
<shortdoc>Set `counter` based OTP with passcode.</shortdoc>
</kw>
<kw name="Set Time Based Otp" lineno="132">
<arguments repr="otp_passcode: str">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="otp_passcode: str">
<name>otp_passcode</name>
<type typedoc="string">str</type>
</arg>
</arguments>
<doc>Set `time` based OTP with passcode.

:param otp_passcode: the passcode provided by the Authenticator</doc>
<shortdoc>Set `time` based OTP with passcode.</shortdoc>
</kw>
<kw name="Use Mfa Secret From Vault" lineno="116">
<arguments repr="vault_name: str, vault_key: str, mode: OTPMode = TIME">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="vault_name: str">
<name>vault_name</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="vault_key: str">
<name>vault_key</name>
<type typedoc="string">str</type>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="mode: OTPMode = TIME">
<name>mode</name>
<type typedoc="OTPMode">OTPMode</type>
<default>TIME</default>
</arg>
</arguments>
<doc>Set `time` or `counter` based OTP with passcode stored in
the Robocorp Vault named with `vault_name` under key of `vault_key`.

:param vault_name: name of the vault storing the passcode
:param vault_key: name of the vault key storing the passcode value</doc>
<shortdoc>Set `time` or `counter` based OTP with passcode stored in the Robocorp Vault named with `vault_name` under key of `vault_key`.</shortdoc>
</kw>
</keywords>
<datatypes>
<enums>
<enum name="OTPMode">
<doc>Enumeration for type of OTP to use.</doc>
<members>
<member name="TIME" value="TIME"/>
<member name="COUNTER" value="COUNTER"/>
</members>
</enum>
</enums>
</datatypes>
<typedocs>
<type name="integer" type="Standard">
<doc>Conversion is done using Python's [https://docs.python.org/library/functions.html#int|int]
built-in function. Floating point
numbers are accepted only if they can be represented as integers exactly.
For example, ``1.0`` is accepted and ``1.1`` is not.

Starting from RF 4.1, it is possible to use hexadecimal, octal and binary
numbers by prefixing values with ``0x``, ``0o`` and ``0b``, respectively.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``42``, ``-1``, ``0b1010``, ``10 000 000``, ``0xBAD_C0FFEE``
</doc>
<accepts>
<type>string</type>
<type>float</type>
</accepts>
<usages>
<usage>Get Counter Based Otp</usage>
</usages>
</type>
<type name="None" type="Standard">
<doc>String ``NONE`` (case-insensitive) is converted to Python ``None`` object.
Other values cause an error.
</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Get Counter Based Otp</usage>
<usage>Get Time Based Otp</usage>
<usage>Refresh Oauth Token</usage>
</usages>
</type>
<type name="OTPMode" type="Enum">
<doc>Enumeration for type of OTP to use.</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Use Mfa Secret From Vault</usage>
</usages>
<members>
<member name="TIME" value="TIME"/>
<member name="COUNTER" value="COUNTER"/>
</members>
</type>
<type name="string" type="Standard">
<doc>All arguments are converted to Unicode strings.</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Generate Oauth Url</usage>
<usage>Get Counter Based Otp</usage>
<usage>Get Oauth Token</usage>
<usage>Get Time Based Otp</usage>
<usage>Refresh Oauth Token</usage>
<usage>Set Counter Based Otp</usage>
<usage>Set Time Based Otp</usage>
<usage>Use Mfa Secret From Vault</usage>
</usages>
</type>
</typedocs>
</keywordspec>
